% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{我}{们之前已经看到}，当我们在范畴 $\cat{C}$ 中固定一个对象 $a$ 时，映射 $\cat{C}(a, -)$ 是一个从 $\cat{C}$ 到 $\Set$ 的（协变）函子 (covariant functor)。
\[x \to \cat{C}(a, x)\]
（其陪域 (codomain) 是 $\Set$，因为 hom-集 (hom-set) $\cat{C}(a, x)$ 是一个 \emph{集合}。）我们称这个映射为 hom-函子 (hom-functor)——我们之前也定义了它在态射 (morphisms) 上的作用。

现在让我们在这个映射中改变 $a$。我们得到一个新的映射，它将 hom-\emph{函子} $\cat{C}(a, -)$ 赋给任意 $a$。
\[a \to \cat{C}(a, -)\]
这是一个从范畴 $\cat{C}$ 的对象到函子的映射，而函子是函子范畴 (functor category) 中的 \emph{对象}（参见 \hyperref[natural-transformations]{自然变换} 中关于函子范畴的部分）。让我们使用记号 $[\cat{C}, \Set]$ 来表示从 $\cat{C}$ 到 $\Set$ 的函子范畴。你可能还记得 hom-函子是典型的 \hyperref[representable-functors]{可表示函子 (representable functors)}。

每当我们在两个范畴之间有一个对象的映射时，很自然地会问这个映射是否也是一个函子。换句话说，我们是否可以将一个范畴中的态射提升 (lift) 为另一个范畴中的态射。$\cat{C}$ 中的态射只是 $\cat{C}(a, b)$ 的一个元素，但函子范畴 $[\cat{C}, \Set]$ 中的态射是一个自然变换 (natural transformation)。所以我们在寻找一个从态射到自然变换的映射。

让我们看看是否能找到一个对应于态射 $f \Colon a \to b$ 的自然变换。首先，让我们看看 $a$ 和 $b$ 被映射到了什么。它们被映射到两个函子：$\cat{C}(a, -)$ 和 $\cat{C}(b, -)$。我们需要这两个函子之间的一个自然变换。

这里的技巧是：我们使用 Yoneda 引理 (Yoneda lemma)：
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
并将泛型 (generic) $F$ 替换为 hom-函子 $\cat{C}(b, -)$。我们得到：
\[[\cat{C}, \Set](\cat{C}(a, -), \cat{C}(b, -)) \cong \cat{C}(b, a)\]
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/yoneda-embedding.jpg}
\end{figure}

\noindent
这正是我们寻找的两个 hom-函子之间的自然变换，但有一个小小的转折：我们有一个自然变换和一个态射——$\cat{C}(b, a)$ 的一个元素——之间的映射，但方向是“错误”的。但这没关系；这只意味着我们正在考察的函子是逆变的 (contravariant)。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{images/yoneda-embedding-2.jpg}
\end{figure}

\noindent
实际上，我们得到的比预期的还要多。从 $\cat{C}$ 到 $[\cat{C}, \Set]$ 的映射不仅是一个逆变函子——它还是一个 \emph{完全忠实} 函子 (fully faithful functor)。满性 (Fullness) 和忠实性 (faithfulness) 是描述函子如何映射 hom-集的性质。

一个 \emph{忠实} 函子 (faithful functor) 在 hom-集上是 \newterm{单射的 (injective)}，意味着它将不同的态射映射到不同的态射。换句话说，它不会合并它们。

一个 \emph{满} 函子 (full functor) 在 hom-集上是 \newterm{满射的 (surjective)}，意味着它将一个 hom-集映射 \emph{到} 另一个 hom-集上，完全覆盖后者。

一个完全忠实函子 $F$ 在 hom-集上是 \newterm{双射 (bijection)}——两个集合所有元素的一一匹配。对于源范畴 $\cat{C}$ 中的每一对对象 $a$ 和 $b$，在 $\cat{C}(a, b)$ 和 $\cat{D}(F a, F b)$ 之间存在一个双射，其中 $\cat{D}$ 是 $F$ 的目标范畴（在我们的例子中，是函子范畴 $[\cat{C}, \Set]$）。注意这并不意味着 $F$ 在 \emph{对象} 上是双射。在 $\cat{D}$ 中可能存在不属于 $F$ 的像 (image) 的对象，对于那些对象，我们无法对 hom-集说任何话。

\section{嵌入}

我们刚刚描述的（逆变）函子，即那个将 $\cat{C}$ 中的对象映射到 $[\cat{C}, \Set]$ 中函子的函子：
\[a \to \cat{C}(a, -)\]
定义了 \newterm{Yoneda 嵌入 (Yoneda embedding)}。它将范畴 $\cat{C}$（严格来说，是范畴 $\cat{C}^\mathit{op}$，因为它是逆变的）\emph{嵌入 (embeds)} 到函子范畴 $[\cat{C}, \Set]$ 内部。它不仅将 $\cat{C}$ 中的对象映射为函子，而且还忠实地保留了它们之间的所有连接。

这是一个非常有用的结果，因为数学家们对函子范畴了解很多，特别是那些陪域为 $\Set$ 的函子。通过将任意范畴 $\cat{C}$ 嵌入到函子范畴中，我们可以获得很多关于它的洞察。

当然，存在 Yoneda 嵌入的对偶 (dual) 版本，有时称为 co-Yoneda 嵌入 (co-Yoneda embedding)。观察一下，我们本可以从固定每个 hom-集的目标对象（而不是源对象）$\cat{C}(-, a)$ 开始。那会给我们一个逆变 hom-函子。从 $\cat{C}$ 到 $\Set$ 的逆变函子是我们熟悉的预层 (presheaves)（例如，参见 \hyperref[limits-and-colimits]{极限与余极限}）。co-Yoneda 嵌入定义了范畴 $\cat{C}$ 在预层范畴中的嵌入。它在态射上的作用由下式给出：
\[[\cat{C}^\mathit{op}, \Set](\cat{C}(-, a), \cat{C}(-, b)) \cong \cat{C}(a, b)\]
同样，数学家们对预层范畴了解很多，因此能够将任意范畴嵌入其中是一个巨大的胜利。

\section{在 Haskell 中的应用}

在 Haskell 中，Yoneda 嵌入可以表示为一方面是 reader 函子之间的自然变换，另一方面是（反方向的）函数之间的同构 (isomorphism)：

\begin{snipv}
forall x. (a -> x) -> (b -> x) \ensuremath{\cong} b -> a
\end{snipv}
（请记住，reader 函子等价于 \code{((->) a)}。）

这个等式的左边是一个多态函数，给定一个从 \code{a} 到 \code{x} 的函数和一个 \code{b} 类型的值，它可以产生一个 \code{x} 类型的值（我正在对函数 \code{b -> x} 进行 uncurrying——去掉周围的括号）。对于所有的 \code{x}，能够做到这一点的唯一方法是，我们的函数知道如何将一个 \code{b} 转换为一个 \code{a}。它必须秘密地能够访问一个函数 \code{b -> a}。

给定这样一个转换器 \code{btoa}，可以定义左侧，称之为 \code{fromY}，如下：

\src{snippet01}
反过来，给定一个函数 \code{fromY}，我们可以通过用恒等函数 (identity) 调用 \code{fromY} 来恢复转换器：

\src{snippet02}
这就在类型为 \code{fromY} 的函数和 \code{btoa} 之间建立了一个双射。

看待这个同构的另一种方式是，它是从 \code{b} 到 \code{a} 的函数的 \acronym{CPS} 编码。参数 \code{a -> x} 是一个续延 (continuation)（处理器）。结果是一个从 \code{b} 到 \code{x} 的函数，当用 \code{b} 类型的值调用它时，它将执行与被编码函数前复合的续延。

Yoneda 嵌入也解释了 Haskell 中数据结构的一些替代表示。特别是，它为 \code{Control.Lens} 库中的透镜 (lenses) 提供了一个 \urlref{https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/}{非常有用的表示}。

\section{预序例子}

这个例子是由 Robert Harper 建议的。它是将 Yoneda 嵌入应用于由预序 (preorder) 定义的范畴。预序是一个集合，其元素之间具有通常写为 $\leqslant$（小于或等于）的排序关系。“预” (pre) 在预序中是因为我们只要求关系是传递的 (transitive) 和自反的 (reflexive)，但不一定是反对称的 (antisymmetric)（因此可能存在循环）。

具有预序关系的集合产生一个范畴。对象是该集合的元素。从对象 $a$ 到 $b$ 的态射要么不存在，如果对象无法比较或者 $a \leqslant b$ 不成立；要么存在，如果 $a \leqslant b$，并且它从 $a$ 指向 $b$。从一个对象到另一个对象绝不会有多于一个态射。因此，这样一个范畴中的任何 hom-集要么是空集，要么是单元集 (one-element set)。这样的范畴称为 \emph{瘦范畴 (thin category)}。

很容易说服自己这个构造确实是一个范畴：箭头是可组合的，因为如果 $a \leqslant b$ 且 $b \leqslant c$ 则 $a \leqslant c$；并且组合是结合的。我们也有恒等箭头，因为每个元素都（小于或）等于自身（底层关系的自反性）。

我们现在可以将 co-Yoneda 嵌入应用于预序范畴。特别是，我们对其在态射上的作用感兴趣：
\[[\cat{C}, \Set](\cat{C}(-, a), \cat{C}(-, b)) \cong \cat{C}(a, b)\]
右侧的 hom-集非空当且仅当 $a \leqslant b$——在这种情况下它是一个单元集。因此，如果 $a \leqslant b$，则左侧存在唯一的自然变换。否则不存在自然变换。

那么，预序中 hom-函子之间的自然变换是什么？它应该是一族在集合 $\cat{C}(-, a)$ 和 $\cat{C}(-, b)$ 之间的函数。在预序中，这些集合中的每一个要么是空的，要么是单元集。让我们看看我们有哪些函数可用。

有一个从空集到自身的函数（作用于空集的恒等函数），一个函数 \code{absurd} 从空集到单元集（它什么也不做，因为它只需要为没有元素的空集的元素定义），以及一个从单元集到自身的函数（作用于单元集的恒等函数）。唯一被禁止的组合是从单元集到空集的映射（这样一个函数作用于单个元素时的值会是什么？）。

因此，我们的自然变换永远不会将一个单元 hom-集连接到一个空 hom-集。换句话说，如果 $x \leqslant a$（单元 hom-集 $\cat{C}(x, a)$），那么 $\cat{C}(x, b)$ 不能为空。一个非空的 $\cat{C}(x, b)$ 意味着 $x$ 小于或等于 $b$。所以所讨论的自然变换的存在要求对于每个 $x$，如果 $x \leqslant a$ 则 $x \leqslant b$。
\[\text{对于所有 } x, x \leqslant a \Rightarrow x \leqslant b\]
另一方面，co-Yoneda 告诉我们这个自然变换的存在等价于 $\cat{C}(a, b)$ 非空，或者说 $a \leqslant b$。合在一起，我们得到：
\[a \leqslant b \text{ 当且仅当对于所有 } x, x \leqslant a \Rightarrow x \leqslant b\]
我们本可以直接得到这个结果。直觉是，如果 $a \leqslant b$，那么所有低于 $a$ 的元素也必须低于 $b$。反过来，当你在右侧用 $a$ 替换 $x$ 时，可以推断出 $a \leqslant b$。但你必须承认，通过 Yoneda 嵌入得到这个结果要令人兴奋得多。

\section{自然性}

Yoneda 引理建立了自然变换集合与 $\Set$ 中一个对象之间的同构。自然变换是函子范畴 $[\cat{C}, \Set]$ 中的态射。任意两个函子之间的自然变换集合是该范畴中的一个 hom-集。Yoneda 引理是这个同构：
\[[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a\]
这个同构结果在 $F$ 和 $a$ 两方面都是自然的。换句话说，它在 $(F, a)$ 上是自然的，这是从积范畴 (product category) $[\cat{C}, \Set] \times \cat{C}$ 中取出的一个对。注意，我们现在将 $F$ 视为函子范畴中的一个 \newterm{对象 (object)}。

让我们思考一下这意味着什么。一个自然同构 (natural isomorphism) 是两个函子之间的一个可逆的 \emph{自然变换}。确实，我们同构的右侧是一个函子。它是一个从 $[\cat{C}, \Set] \times \cat{C}$ 到 $\Set$ 的函子。它作用于一对 $(F, a)$ 的结果是一个集合——即函子 $F$ 在对象 $a$ 上的求值结果。这被称为求值函子 (evaluation functor)。

左侧也是一个函子，它将 $(F, a)$ 映射到一个自然变换的集合 $[\cat{C}, \Set](\cat{C}(a, -), F)$。

为了表明它们确实是函子，我们还应该定义它们在态射上的作用。但是一对 $(F, a)$ 和 $(G, b)$ 之间的态射是什么？它是一对态射 $(\Phi, f)$；第一个是函子之间的态射——一个自然变换——第二个是 $\cat{C}$ 中的常规态射。

求值函子取这个对 $(\Phi, f)$ 并将其映射到两个集合 $F a$ 和 $G b$ 之间的一个函数。我们可以很容易地从 $\Phi$ 在 $a$ 处的分量（它将 $F a$ 映射到 $G a$）和由 $G$ 提升的态射 $f$ 来构造这样一个函数：
\[(G f) \circ \Phi_a\]
注意，由于 $\Phi$ 的自然性，这与以下相同：
\[\Phi_b \circ (F f)\]
我不会去证明整个同构的自然性——在你确定了函子是什么之后，证明过程是相当机械化的。它源于我们的同构是由函子和自然变换构建起来的事实。它根本不可能出错。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        在 Haskell 中表达 co-Yoneda 嵌入。
  \item
        证明我们在 \code{fromY} 和 \code{btoa} 之间建立的双射是一个同构（两个映射互为逆运算）。
  \item
        推导幺半群的 Yoneda 嵌入。哪个函子对应于幺半群的单个对象？哪些自然变换对应于幺半群态射？
  \item
        将 \emph{协变} Yoneda 嵌入应用于预序是什么？（Gershom Bazerman 建议的问题。）
  \item
        Yoneda 嵌入可用于将任意函子范畴 $[\cat{C}, \cat{D}]$ 嵌入到函子范畴 $[[\cat{C}, \cat{D}], \Set]$ 中。弄清楚它如何作用于态射（在这种情况下是自然变换）。
\end{enumerate}