% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{我}{们讨论过} functors (函子) 作为保持其结构的 categories (范畴) 之间的映射。

函子将一个范畴“嵌入”到另一个范畴中。它可能会将多个事物坍缩为一个，但它从不破坏连接。一种思考方式是，通过函子，我们在一个范畴内部建模另一个范畴。源范畴充当模型，一个 blueprint (蓝图)，用于构建目标范畴中某个结构的一部分。

\begin{figure}[H]
  \centering\includegraphics[width=0.4\textwidth]{images/1_functors.jpg}
\end{figure}

\noindent
将一个范畴嵌入到另一个范畴中可能有多种方式。有时它们是等价的，有时则截然不同。一种方式可能将整个源范畴坍缩为一个 object (对象)，另一种方式可能将每个对象映射到不同的对象，每个 morphism (态射) 映射到不同的态射。同一个蓝图可能以多种不同的方式实现。Natural transformations (自然变换) 帮助我们比较这些实现。它们是函子之间的映射——保持其 functorial nature (函子性) 的特殊映射。

考虑范畴 $\cat{C}$ 和 $\cat{D}$ 之间的两个函子 $F$ 和 $G$。如果你只关注 $\cat{C}$ 中的一个对象 $a$，它被映射到两个对象：$F a$ 和 $G a$。因此，函子的映射应该将 $F a$ 映射到 $G a$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/2_natcomp.jpg}
\end{figure}

\noindent
注意 $F a$ 和 $G a$ 是同一范畴 $\cat{D}$ 中的对象。同一范畴中对象之间的映射不应违背该范畴的固有结构。我们不想在对象之间建立 artificial connections (人为的连接)。因此，使用现有的连接，即态射，是 \emph{natural} (自然) 的。自然变换是一系列态射的选择：对于每个对象 $a$，它从 $F a$ 到 $G a$ 挑选一个态射。如果我们将自然变换称为 $\alpha$，这个态射被称为 $\alpha$ 在 $a$ 处的 \newterm{component} (分量)，或记为 $\alpha_a$。

\[\alpha_a \Colon F a \to G a\]
请记住，$a$ 是 $\cat{C}$ 中的一个对象，而 $\alpha_a$ 是 $\cat{D}$ 中的一个态射。

如果对于某个 $a$，在 $\cat{D}$ 中 $F a$ 和 $G a$ 之间没有态射，那么 $F$ 和 $G$ 之间就不可能存在自然变换。

当然，这只是故事的一半，因为函子不仅映射对象，它们也映射态射。那么自然变换对这些映射做了什么呢？事实证明，态射的映射是固定的——在 $F$ 和 $G$ 之间的任何自然变换下，$F f$ 必须被变换为 $G f$。更重要的是，这两个函子对态射的映射极大地限制了我们在定义与之兼容的自然变换时的选择。考虑 $\cat{C}$ 中两个对象 $a$ 和 $b$ 之间的一个态射 $f$。它被映射到 $\cat{D}$ 中的两个态射，$F f$ 和 $G f$：

\begin{gather*}
  F f \Colon F a \to F b \\
  G f \Colon G a \to G b
\end{gather*}
自然变换 $\alpha$ 提供了两个额外的态射，用于补全 \emph{D} 中的图表：

\begin{gather*}
  \alpha_a \Colon F a \to G a \\
  \alpha_b \Colon F b \to G b
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/3_naturality.jpg}
\end{figure}

\noindent
现在我们有两条从 $F a$ 到 $G b$ 的路径。为了确保它们相等，我们必须施加对任何 $f$ 都成立的 \newterm{naturality condition} (自然性条件)：

\[G f \circ \alpha_a = \alpha_b \circ F f\]
自然性条件是一个相当严格的要求。例如，如果态射 $F f$ 是 invertible (可逆的)，自然性条件就根据 $\alpha_a$ 确定了 $\alpha_b$。它沿着 $f$ \emph{transports} (传送) $\alpha_a$：

\[\alpha_b = (G f) \circ \alpha_a \circ (F f)^{-1}\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/4_transport.jpg}
\end{figure}

\noindent
如果两个对象之间存在多个可逆态射，所有这些传送必须一致。然而，通常情况下，态射是不可逆的；但你可以看到，两个函子之间存在自然变换远非必然。因此，由自然变换关联的函子的稀少或丰富，可以告诉你很多关于它们运作的范畴结构的信息。当我们讨论 limits (极限) 和 the Yoneda lemma (米田引理) 时，我们会看到一些例子。

从分量的角度看自然变换，可以说它将对象映射为态射。由于自然性条件，也可以说它将态射映射为 commuting squares (交换方图)——对于 $\cat{C}$ 中的每个态射，在 $\cat{D}$ 中都有一个交换的自然性方图。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/naturality.jpg}
\end{figure}

\noindent
自然变换的这个属性在许多 categorical constructions (范畴构造) 中非常方便，这些构造通常包含交换图。通过明智地选择函子，许多这些 commutativity conditions (交换性条件) 可以转化为自然性条件。当我们讲到极限、colimits (余极限) 和 adjunctions (伴随) 时，我们会看到例子。

最后，自然变换可以用来定义函子的 isomorphisms (同构)。说两个函子是 naturally isomorphic (自然同构) 几乎等于说它们是相同的。\newterm{Natural isomorphism} (自然同构) 被定义为其所有分量都是 isomorphisms (同构，即可逆态射) 的自然变换。

\section{多态函数}

我们讨论了函子（或更具体地说是 endofunctors (自函子)）在编程中的作用。它们对应于将 types (类型) 映射到类型的 type constructors (类型构造器)。它们还将 functions (函数) 映射到函数，这种映射由 higher order function (高阶函数) \code{fmap}（或 C++ 中的 \code{transform}、\code{then} 等）实现。

要构造一个自然变换，我们从一个对象开始，这里是一个类型 \code{a}。一个函子 \code{F} 将其映射到类型 $F a$。另一个函子 \code{G} 将其映射到 $G a$。自然变换 \code{alpha} 在 \code{a} 处的分量是一个从 $F a$ 到 $G a$ 的函数。用伪 Haskell 表示：

\begin{snipv}
alpha\textsubscript{a} :: F a -> G a
\end{snipv}
自然变换是一个对所有类型 \code{a} 都定义的 polymorphic function (多态函数)：

\src{snippet01}
\code{forall a} 在 Haskell 中是可选的（实际上需要开启语言扩展 \code{ExplicitForAll}）。通常，你会这样写：

\src{snippet02}
请记住，它实际上是由 \code{a} 参数化的一族函数。这是 Haskell 语法简洁性的另一个例子。C++ 中的类似构造会稍微冗长一些：

\begin{snip}{cpp}
template<class A> G<A> alpha(F<A>);
\end{snip}
Haskell 的多态函数和 C++ 的 generic functions (泛型函数) 之间存在更深层次的区别，这反映在这些函数的实现和类型检查方式上。在 Haskell 中，多态函数必须对所有类型统一定义。一个公式必须适用于所有类型。这被称为 \newterm{parametric polymorphism} (参数多态)。

另一方面，C++ 默认支持 \newterm{ad hoc polymorphism} (特设多态)，这意味着模板不必对所有类型都定义良好。模板是否适用于给定类型是在 instantiation time (实例化时) 决定的，即用具体类型替换类型参数时。Type checking (类型检查) 被推迟，这不幸地常常导致难以理解的错误消息。

在 C++ 中，还有 function overloading (函数重载) 和 template specialization (模板特化) 的机制，允许对不同类型使用相同函数的不同定义。在 Haskell 中，此功能由 type classes (类型类) 和 type families (类型族) 提供。

Haskell 的参数多态有一个意想不到的后果：任何类型为：

\src{snippet03}
的多态函数，其中 \code{F} 和 \code{G} 是函子，都自动满足自然性条件。这是 categorical notation (范畴论表示法)（$f$ 是一个函数 $f \Colon a \to b$）：

\[G f \circ \alpha_a = \alpha_b \circ F f\]
在 Haskell 中，函子 \code{G} 在态射 \code{f} 上的作用是使用 \code{fmap} 实现的。我将首先用伪 Haskell 写出，带有显式类型注释：

\begin{snipv}
fmap\textsubscript{G} f . alpha\textsubscript{a} = alpha\textsubscript{b} . fmap\textsubscript{F} f
\end{snipv}
由于 type inference (类型推断)，这些注释不是必需的，并且以下等式成立：

\begin{snip}{text}
fmap f . alpha = alpha . fmap f
\end{snip}
这仍然不是真正的 Haskell 代码——函数相等性在代码中无法表达——但它是一个程序员可以在 equational reasoning (等式推理) 中使用的恒等式；或者编译器可以用它来实现 optimizations (优化)。

自然性条件在 Haskell 中自动满足的原因与 ``theorems for free (免费定理)'' 有关。用于在 Haskell 中定义自然变换的参数多态对实现施加了非常强的限制——一个公式适用于所有类型。这些限制转化为关于此类函数的等式定理。在转换函子的函数的情况下，免费定理就是自然性条件。\footnote{
  你可以在我的博客 \href{https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/}{``Parametricity: Money for Nothing and Theorems for Free''} 中阅读更多关于免费定理的内容。}

我之前提到的一种思考 Haskell 中函子的方式是将它们视为 generalized containers (广义容器)。我们可以延续这个类比，将自然变换视为将一个容器的内容 repackaging (重新包装) 到另一个容器的 recipes (配方)。我们不触及 items (物品) 本身：我们不修改它们，也不创建新的。我们只是将（部分）它们 copying (复制)，有时是多次，到一个新的容器中。

自然性条件变成了这样的陈述：先通过应用 \code{fmap} 修改物品，然后再重新包装；或者先重新包装，然后在新的容器中用其自身的 \code{fmap} 实现修改物品，这两者结果是一样的。这两个动作，重新包装和 \code{fmap}ping，是 orthogonal (正交的)。“One moves the eggs, the other boils them (一个移动鸡蛋，另一个煮鸡蛋)。”

让我们看几个 Haskell 中自然变换的例子。第一个是在 list functor (列表函子) 和 \code{Maybe} 函子之间。它返回列表的 head (头部)，但前提是列表非空：

\src{snippet04}
它是一个在 \code{a} 上多态的函数。它适用于任何类型 \code{a}，没有任何限制，所以它是参数多态的一个例子。因此，它是这两个函子之间的自然变换。但为了说服我们自己，让我们验证一下自然性条件。

\src{snippet05}
我们需要考虑两种情况；一个 empty list (空列表)：

\src{snippet06}

\src{snippet07}
和一个 non-empty list (非空列表)：

\src{snippet08}

\src{snippet09}
我使用了列表的 \code{fmap} 实现：

\src{snippet10}
和 \code{Maybe} 的 \code{fmap} 实现：

\src{snippet11}
一个有趣的情况是当其中一个函子是平凡的 \code{Const} 函子时。从 \code{Const} 函子出发或到达 \code{Const} 函子的自然变换看起来就像一个要么在其 return type (返回类型) 上多态，要么在其 argument type (参数类型) 上多态的函数。

例如，\code{length} 可以被认为是 从列表函子到 \code{Const Int} 函子的自然变换：

\src{snippet12}
这里，\code{unConst} 用于剥离 \code{Const} 构造器：

\src{snippet13}
当然，在实践中 \code{length} 被定义为：

\src{snippet14}
这有效地隐藏了它是一个自然变换的事实。

找到一个\emph{从} \code{Const} 函子出发的参数多态函数有点困难，因为它需要从无到有地创建一个值。我们能做的最好的是：

\src{snippet15}
我们已经见过的另一个常见函子，并将在米田引理中扮演重要角色的是 \code{Reader} 函子。我将把它重写为一个 \code{newtype} 定义：

\src{snippet16}
它由两个类型参数化，但仅在第二个类型上是 (covariantly) functorial (（协变）函子性的)：

\src{snippet17}
对于每种类型 \code{e}，你可以定义一族从 \code{Reader e} 到任何其他函子 \code{f} 的自然变换。我们稍后会看到，这个族中的成员总是与 \code{f e} 的元素一一对应（\hyperref[the-yoneda-lemma]{Yoneda lemma (米田引理)}）。

例如，考虑有点平凡的 unit type (单位类型) \code{()}，它只有一个元素 \code{()}。函子 \code{Reader ()} 接受任何类型 \code{a} 并将其映射到函数类型 \code{() -> a}。这些正是从集合 \code{a} 中挑选单个元素的所有函数。它们的数量与 \code{a} 中的元素数量相同。现在让我们考虑从这个函子到 \code{Maybe} 函子的自然变换：

\src{snippet18}
只有两个这样的变换，\code{dumb} 和 \code{obvious}：

\src{snippet19}
和

\src{snippet20}
（你能对 \code{g} 做的唯一事情就是将它应用于单位值 \code{()}。）

并且，正如米田引理所预测的那样，这确实对应于 \code{Maybe ()} 类型的两个元素，即 \code{Nothing} 和 \code{Just ()}。我们稍后会回到米田引理——这只是一个小小的 teaser (预告)。

\section{超越自然性}

两个函子（包括 \code{Const} 函子的 edge case (边缘情况)）之间的参数多态函数总是一个自然变换。由于所有标准的 algebraic data types (代数数据类型) 都是函子，因此这些类型之间的任何多态函数都是自然变换。

我们也可以使用函数类型，它们在其返回类型上是函子性的。我们可以用它们来构建函子（如 \code{Reader} 函子）并定义作为高阶函数的自然变换。

然而，函数类型在其参数类型上不是 covariant (协变的)。它们是 \newterm{contravariant} (逆变的)。当然，逆变函子等价于从 opposite category (对偶范畴) 出发的协变函子。两个逆变函子之间的多态函数在 categorical sense (范畴意义) 上仍然是自然变换，只不过它们作用于从对偶范畴到 Haskell 类型的函子上。

你可能还记得我们之前看过的逆变函子的例子：

\src{snippet21}
这个函子在 \code{a} 上是逆变的：

\src{snippet22}
我们可以编写一个从（比如）\code{Op Bool} 到 \code{Op String} 的多态函数：

\src{snippet23}
但是由于这两个函子不是协变的，这不是 $\Hask$ 中的自然变换。然而，因为它们都是逆变的，它们满足“相反的”自然性条件：

\src{snippet24}[b]
注意函数 \code{f} 的方向必须与你用于 \code{fmap} 的方向相反，这是因为 \code{contramap} 的签名：

\src{snippet25}
是否存在既非协变也非逆变的类型构造器？这里有一个例子：

\src{snippet26}
这不是一个函子，因为同一个类型 \code{a} 同时出现在 negative (contravariant) (负（逆变）) 和 positive (covariant) (正（协变）) 位置。你无法为这个类型实现 \code{fmap} 或 \code{contramap}。因此，签名为：

\src{snippet27}
的函数，其中 \code{f} 是任意函子，不可能是自然变换。有趣的是，存在自然变换的一种 generalization (推广)，称为 dinatural transformations (双自然变换)，可以处理这种情况。我们将在讨论 ends (端) 时接触它们。

\section{函子范畴}

既然我们有了函子之间的映射——自然变换——很自然地会问：函子是否构成一个范畴？答案是肯定的！对于每一对范畴 $\cat{C}$ 和 $\cat{D}$，都有一个 category of functors (函子范畴)。这个范畴中的对象是从 $\cat{C}$ 到 $\cat{D}$ 的函子，而态射是这些函子之间的自然变换。

我们必须定义两个自然变换的 composition (复合)，但这相当容易。自然变换的分量是态射，我们知道如何复合态射。

确实，让我们取一个从函子 $F$ 到 $G$ 的自然变换 $\alpha$。它在对象 $a$ 处的分量是某个态射：
\[\alpha_a \Colon F a \to G a\]
我们想将 $\alpha$ 与 $\beta$ 复合，$\beta$ 是从函子 $G$ 到 $H$ 的自然变换。$\beta$ 在 $a$ 处的分量是一个态射：
\[\beta_a \Colon G a \to H a\]
这些态射是可复合的，它们的复合是另一个态射：
\[\beta_a \circ \alpha_a \Colon F a \to H a\]
我们将使用这个态射作为自然变换 $\beta \cdot \alpha$——即先应用 $\alpha$ 再应用 $\beta$ 的两个自然变换的复合——的分量：
\[(\beta \cdot \alpha)_a = \beta_a \circ \alpha_a\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/5_vertical.jpg}
\end{figure}

\noindent
仔细（长时间）观察一个 diagram (图表) 可以让我们相信，这种复合的结果确实是一个从 F 到 H 的自然变换：
\[H f \circ (\beta \cdot \alpha)_a = (\beta \cdot \alpha)_b \circ F f\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/6_verticalnaturality.jpg}
\end{figure}

\noindent
自然变换的复合是 associative (结合的)，因为它们的分量（常规态射）相对于它们的复合是结合的。

最后，对于每个函子 $F$，都有一个 identity natural transformation (单位自然变换) $1_F$，其分量是 identity morphisms (单位态射)：
\[\id_{F a} \Colon F a \to F a\]
所以，函子确实构成一个范畴。

关于 notation (表示法) 的一点说明。我遵循 Saunders Mac Lane 的做法，对刚刚描述的那种自然变换复合使用点号。问题在于有两种复合自然变换的方式。这种称为 vertical composition (垂直复合)，因为在描述它的图表中，函子通常是垂直堆叠的。垂直复合在定义 the functor category (函子范畴) 时很重要。我稍后会解释 horizontal composition (水平复合)。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/6a_vertical.jpg}
\end{figure}

\noindent
范畴 $\cat{C}$ 和 $\cat{D}$ 之间的函子范畴写作 $\cat{Fun(C, D)}$，或 $\cat{{[}C, D{]}}$，有时也写作 $\cat{D^C}$。后一种表示法暗示函子范畴本身可能被视为某个其他范畴中的 function object (函数对象)（一个 exponential (指数对象)）。情况确实如此吗？

让我们看一下我们迄今为止建立的 hierarchy of abstractions (抽象层次结构)。我们从范畴开始，它是对象和态射的集合。范畴本身（或者严格来说是 \emph{small} categories (小范畴)，其对象构成 sets (集合)）是更高层级范畴 $\Cat$ 中的对象。该范畴中的态射是函子。$\Cat$ 中的 Hom-set (态射集合) 是函子的集合。例如 $\cat{Cat(C, D)}$ 是两个范畴 $\cat{C}$ 和 $\cat{D}$ 之间函子的集合。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/7_cathomset.jpg}
\end{figure}

\noindent
函子范畴 $\cat{{[}C, D{]}}$ 也是两个范畴之间函子的集合（加上作为态射的自然变换）。它的对象与 $\cat{Cat(C, D)}$ 的成员相同。此外，函子范畴作为一个范畴，本身必须是 $\Cat$ 的一个对象（恰好两个小范畴之间的函子范畴本身也是小的）。我们在一个范畴中的 Hom-set 和同一个范畴中的对象之间建立了一种关系。这种情况与我们在上一节中看到的指数对象完全一样。让我们看看如何在 $\Cat$ 中构造后者。

你可能还记得，为了构造指数对象，我们需要首先定义一个 product (积)。在 $\Cat$ 中，这相对容易，因为小范畴是对象的 \emph{sets} (集合)，而我们知道如何定义 Cartesian products (笛卡尔积) of sets。因此，积范畴 $\cat{C\times D}$ 中的一个对象只是一个对象对 $(c, d)$，一个来自 $\cat{C}$，一个来自 $\cat{D}$。类似地，两个这样的对 $(c, d)$ 和 $(c', d')$ 之间的态射是一对态射 $(f, g)$，其中 $f \Colon c \to c'$ 且 $g \Colon d \to d'$。这些态射对按分量复合，并且总有一个单位对，它只是一对单位态射。To make the long story short (长话短说)，$\Cat$ 是一个完全成熟的 Cartesian closed category (笛卡尔闭范畴)，其中对于任何一对范畴都存在一个指数对象 $\cat{D^C}$。并且，当我说 $\Cat$ 中的“对象”时，我指的是一个范畴，所以 $\cat{D^C}$ 是一个范畴，我们可以将其等同于 $\cat{C}$ 和 $\cat{D}$ 之间的函子范畴。

\section{2-范畴}

解决了这个问题之后，让我们仔细看看 $\Cat$。根据定义，$\Cat$ 中的任何 Hom-set 都是函子的集合。但是，正如我们所见，两个对象之间的函子具有比仅仅是集合更丰富的结构。它们构成一个范畴，以自然变换作为态射。由于函子在 $\Cat$ 中被视为态射，自然变换就是态射之间的态射。

这种更丰富的结构是 a $\cat{2}{}$-category (2-范畴) 的一个例子，它是范畴的一种推广，其中除了对象和态射（在此上下文中可称为 $1$-morphisms (1-态射)）之外，还有 $2$-morphisms (2-态射)，即态射之间的态射。

在将 $\Cat$ 视为一个 $\cat{2}{}$-category 的情况下，我们有：

\begin{itemize}
  \tightlist
  \item
        Objects (对象): (Small) categories (（小）范畴)
  \item
        1-morphisms (1-态射): Functors between categories (范畴之间的函子)
  \item
        2-morphisms (2-态射): Natural transformations between functors (函子之间的自然变换).
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/8_cat-2-cat.jpg}
\end{figure}

\noindent
在两个范畴 $\cat{C}$ 和 $\cat{D}$ 之间，我们不再只有一个 Hom-set，而是有一个 Hom-category (态射范畴)——函子范畴 $\cat{D^C}$。我们有常规的函子复合：来自 $\cat{D^C}$ 的函子 $F$ 与来自 $\cat{E^D}$ 的函子 $G$ 复合得到来自 $\cat{E^C}$ 的 $G \circ F$。但我们也在每个 Hom-范畴内部有复合——函子之间自然变换（即 2-态射）的垂直复合。

在一个 $\cat{2}{}$-category 中有两种复合，问题来了：它们之间如何相互作用？

让我们选取 $\Cat$ 中的两个函子，或 1-态射：
\begin{gather*}
  F \Colon \cat{C} \to \cat{D} \\
  G \Colon \cat{D} \to \cat{E}
\end{gather*}
以及它们的复合：
\[G \circ F \Colon \cat{C} \to \cat{E}\]
假设我们有两个自然变换，$\alpha$ 和 $\beta$，分别作用于函子 $F$ 和 $G$：
\begin{gather*}
  \alpha \Colon F \to F' \\
  \beta \Colon G \to G'
\end{gather*}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/10_horizontal.jpg}
\end{figure}

\noindent
注意我们不能对这对应用垂直复合，因为 $\alpha$ 的 target (目标) 与 $\beta$ 的 source (源) 不同。实际上，它们属于两个不同的函子范畴：$\cat{D^C}$ 和 $\cat{E^D}$。然而，我们可以对函子 $F'$ 和 $G'$ 应用复合，因为 $F'$ 的目标是 $G'$ 的源——即范畴 $\cat{D}$。那么函子 $G' \circ F'$ 和 $G \circ F$ 之间有什么关系？

有了 $\alpha$ 和 $\beta$，我们能否定义一个从 $G \circ F$ 到 $G' \circ F'$ 的自然变换？让我 sketch (勾勒) 一下构造过程。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/9_horizontal.jpg}
\end{figure}

\noindent
像往常一样，我们从 $\cat{C}$ 中的一个对象 $a$ 开始。它的 image (像) 分裂成 $\cat{D}$ 中的两个对象：$F a$ 和 $F'a$。还有一个连接这两个对象的态射，即 $\alpha$ 的分量：
\[\alpha_a \Colon F a \to F'a\]
当从 $\cat{D}$ 到 $\cat{E}$ 时，这两个对象进一步分裂成四个对象：$G (F a)$、 $G'(F a)$、 $G (F'a)$、 $G'(F'a)$。我们还有四个态射构成一个 square (正方形)。其中两个态射是自然变换 $\beta$ 的分量：
\begin{gather*}
  \beta_{F a} \Colon G (F a) \to G'(F a) \\
  \beta_{F'a} \Colon G (F'a) \to G'(F'a)
\end{gather*}
另外两个是 $\alpha_a$ 在两个函子下的像（函子映射态射）：
\begin{gather*}
  G \alpha_a \Colon G (F a) \to G (F'a) \\
  G'\alpha_a \Colon G'(F a) \to G'(F'a)
\end{gather*}
这有很多态射。我们的目标是找到一个从 $G (F a)$ 到 $G'(F'a)$ 的态射，作为连接两个函子 $G \circ F$ 和 $G' \circ F'$ 的自然变换分量的候选者。实际上，我们有不止一条路径可以从 $G (F a)$ 走到 $G'(F'a)$：
\begin{gather*}
  G'\alpha_a \circ \beta_{F a} \\
  \beta_{F'a} \circ G \alpha_a
\end{gather*}
Luckily for us (幸运的是)，它们是相等的，因为我们构成的正方形恰好是 $\beta$ 的自然性方图。

我们刚刚定义了从 $G \circ F$ 到 $G' \circ F'$ 的自然变换的一个分量。只要你有足够的 patience (耐心)，证明这个变换的自然性是相当 straightforward (直接的)。

我们称这个自然变换为 $\alpha$ 和 $\beta$ 的 \newterm{horizontal composition} (水平复合)：
\[\beta \circ \alpha \Colon G \circ F \to G' \circ F'\]
再次，我遵循 Mac Lane 使用小圆圈表示水平复合，尽管你也可能遇到用 star (星号) 代替。

这里有一个 categorical rule of thumb (范畴论经验法则)：每当你遇到复合时，就应该寻找一个范畴。我们有自然变换的垂直复合，它是函子范畴的一部分。但是水平复合呢？它存在于哪个范畴中？

弄清楚这一点的方法是 look at $\Cat$ sideways (横向观察 $\Cat$)。不要将自然变换视为函子之间的 arrows (箭头)，而是将其视为范畴之间的箭头。自然变换位于两个范畴之间，即被它变换的函子所连接的那些范畴。我们可以认为它连接了这两个范畴。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{images/sideways.jpg}
\end{figure}

\noindent
让我们关注 $\Cat$ 的两个对象——范畴 $\cat{C}$ 和 $\cat{D}$。存在一组自然变换，它们作用于连接 $\cat{C}$ 到 $\cat{D}$ 的函子之间。这些自然变换是我们从 $\cat{C}$ 到 $\cat{D}$ 的新箭头。By the same token (同理)，存在作用于连接 $\cat{D}$ 到 $\cat{E}$ 的函子之间的自然变换，我们可以将其视为从 $\cat{D}$ 到 $\cat{E}$ 的新箭头。水平复合就是这些箭头的复合。

我们还有一个从 $\cat{C}$ 到 $\cat{C}$ 的 identity arrow (单位箭头)。它是作用于 $\cat{C}$ 上 identity functor (单位函子) 的单位自然变换。注意，水平复合的单位元也是垂直复合的单位元，但 not vice versa (反之则不然)。

Finally (最后)，这两种复合满足 the interchange law (互换律)：
\[(\beta' \cdot \alpha') \circ (\beta \cdot \alpha) = (\beta' \circ \beta) \cdot (\alpha' \circ \alpha)\]
I will quote Saunders Mac Lane here (我在这里引用 Saunders Mac Lane 的话): The reader may enjoy writing down the evident diagrams needed to prove this fact (读者可能会喜欢写下证明这一事实所需的显而易见的图表)。

还有一种可能在将来有用的表示法。在这种新的横向解释 $\Cat$ 的方式中，有两种从对象到对象的方式：使用函子或使用自然变换。然而，我们可以将函子箭头 re-interpret (重新解释) 为一种特殊的自然变换：作用于该函子的单位自然变换。所以你经常会看到这种表示法：
\[F \circ \alpha\]
其中 $F$ 是从 $\cat{D}$ 到 $\cat{E}$ 的函子，$\alpha$ 是从 $\cat{C}$ 到 $\cat{D}$ 的两个函子之间的自然变换。由于你不能将函子与自然变换复合，这被解释为单位自然变换 $1_F$ 在 $\alpha$ 之后的水平复合。

Similarly (类似地)：
\[\alpha \circ F\]
是 $\alpha$ 在 $1_F$ 之后的水平复合。

\section{结论}

本书的第一部分到此结束。我们学习了范畴论的基本 vocabulary (词汇)。你可以将对象和范畴视为 nouns (名词)；将态射、函子和自然变换视为 verbs (动词)。态射连接对象，函子连接范畴，自然变换连接函子。

但我们也看到，在一个抽象层面上表现为 action (动作) 的东西，在下一个层面上变成了对象。态射的集合变成了 function object (函数对象)。作为一个对象，它可以是另一个态射的 source (源) 或 target (目标)。这就是 higher order functions (高阶函数) 背后的思想。

函子将对象映射到对象，所以我们可以将其用作 type constructor (类型构造器)，或 parametric type (参数化类型)。函子也映射态射，所以它是一个高阶函数——\code{fmap}。有一些简单的函子，如 \code{Const}、product (积) 和 coproduct (余积)，可以用来生成各种各样的代数数据类型。函数类型也是函子性的，既有 covariant (协变) 也有 contravariant (逆变)，可以用来扩展代数数据类型。

Functors may be looked upon as objects in the functor category (函子可以被视为函子范畴中的对象)。As such (因此)，它们成为态射的源和目标：自然变换。A natural transformation is a special type of polymorphic function (自然变换是一种特殊类型的多态函数)。

\section{Challenges (挑战)}

\begin{enumerate}
  \tightlist
  \item
        Define a natural transformation from the \code{Maybe} functor to the list functor. Prove the naturality condition for it. (定义一个从 \code{Maybe} 函子到列表函子的自然变换。证明它的自然性条件。)
  \item
        Define at least two different natural transformations between \code{Reader ()} and the list functor. How many different lists of \code{()} are there? (定义 \code{Reader ()} 和列表函子之间至少两个不同的自然变换。存在多少个不同的 \code{()} 列表？)
  \item
        Continue the previous exercise with \code{Reader Bool} and \code{Maybe}. (继续上一个练习，使用 \code{Reader Bool} 和 \code{Maybe}。)
  \item
        Show that horizontal composition of natural transformation satisfies the naturality condition (hint: use components). It's a good exercise in diagram chasing. (证明自然变换的水平复合满足自然性条件（提示：使用分量）。这是图表追踪的一个好练习。)
  \item
        Write a short essay about how you may enjoy writing down the evident diagrams needed to prove the interchange law. (写一篇关于你可能如何享受绘制证明互换律所需之显而易见的图表的短文。)
  \item
        Create a few test cases for the opposite naturality condition of transformations between different \code{Op} functors. Here's one choice: (为不同 \code{Op} 函子之间变换的相反自然性条件创建一些测试用例。这里有一个选择：)

        \begin{snip}{haskell}
op :: Op Bool Int
op = Op (\x -> x > 0)
\end{snip}
        and (和)

        \begin{snip}{haskell}
f :: String -> Int
f x = read x
\end{snip}
\end{enumerate}