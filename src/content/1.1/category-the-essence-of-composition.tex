% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{一}{个} category (范畴) 是一个异常简单的概念。
一个范畴由 \newterm{objects} (对象) 和它们之间的 \newterm{arrows} (箭头) 组成。这就是
为什么范畴如此容易用图形表示。一个对象可以
被画成一个圆圈或一个点，而一个箭头……就是一个箭头。(为了
多样性，我偶尔会把对象画成小猪，箭头画成烟花。) 但范畴的本质是 \emph{composition} (组合)。或者，
如果你愿意，组合的本质就是一个范畴。箭头可以组合，所以
如果你有一个从对象 $A$ 到对象 $B$ 的箭头，以及另一个从
对象 $B$ 到对象 $C$ 的箭头，那么必定存在一个箭头 —— 它们的组合
—— 从 $A$ 指向 $C$。

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{images/img_1330.jpg}
  \caption{在一个范畴中，如果有一个从 $A$ 到 $B$ 的箭头和一个从 $B$ 到 $C$ 的箭头，
    那么也必定存在一个从 $A$ 到 $C$ 的直接箭头，它是它们的组合。这个图并非一个完整的
    范畴，因为它缺少 identity morphisms (恒等态射) (见后文)。}
\end{figure}

\section{作为函数的箭头}

这是否已经是过多的抽象废话了？不要绝望。让我们谈谈
具体的。把箭头，也称为 \newterm{morphisms} (态射)，想象成函数。你有一个函数 $f$，它接受一个类型 $A$ 的参数并
返回一个 $B$。你还有另一个函数 $g$，它接受一个 $B$ 并返回一个 $C$。
你可以通过将 $f$ 的结果传递给 $g$ 来组合它们。你刚刚
定义了一个新的函数，它接受一个 $A$ 并返回一个 $C$。

在数学中，这种组合用函数之间的小圆圈表示：$g \circ f$。注意组合是从右到左的顺序。对某些人来说，这会令人困惑。你可能熟悉
Unix 中的管道符，如：

\begin{snip}{text}
lsof | grep Chrome
\end{snip}
或者 F\# 中的 V 形符号 \code{>>}，它们都
是从左到右的。但在数学和 Haskell 中，函数
是从右到左组合的。如果你把 $g \circ f$ 读作 “g \emph{after} f” (g 在 f 之后)，会有所帮助。

让我们通过写一些 C 代码来使其更明确。我们有一个
函数 \code{f}，它接受一个类型为 \code{A} 的参数并
返回一个类型为 \code{B} 的值：

\begin{snip}{text}
B f(A a);
\end{snip}
以及另一个：

\begin{snip}{text}
C g(B b);
\end{snip}
它们的组合是：

\begin{snip}{text}
C g_after_f(A a)
{
    return g(f(a));
}
\end{snip}
这里，你再次看到了从右到左的组合：\code{g(f(a))}；这次是在 C 语言中。

我希望我能告诉你 C++ 标准库 (Standard Library) 中有一个模板可以接受两个函数并返回它们的组合，但
并没有。所以让我们尝试用 Haskell 来换换口味。这是一个从 A 到 B 的函数的
声明：

\src{snippet01}
类似地：

\src{snippet02}
它们的组合是：

\src{snippet03}
一旦你看到 Haskell 中的事情是多么简单，在 C++ 中无法表达
直观的函数式概念就有点令人尴尬了。事实上，Haskell 允许你使用 Unicode 字符，所以你可以把
组合写成：
% don't 'mathify' this block
\begin{snip}{text}
g ◦ f
\end{snip}

你甚至可以使用 Unicode 双冒号和箭头：
% don't 'mathify' this block
\begin{snipv}
f \ensuremath{\Colon} A → B
\end{snipv}
所以这是第一个 Haskell 课程：双冒号表示“具有……的类型”。函数类型是通过在
两个类型之间插入一个箭头来创建的。你通过在两个函数之间插入一个句点（或一个 Unicode 圆圈）来组合它们。

\section{组合的性质}

任何范畴中的组合都必须满足两个极其重要的性质。

\begin{enumerate}
  \item
        组合是 associative (结合性) 的。如果你有三个可以组合的态射 $f$、$g$ 和 $h$
        （也就是说，它们的对象的首尾相连），你
        不需要括号来组合它们。在数学符号中，这表示为：
        \[h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f\]
        在 (伪) Haskell 代码中：

        \src{snippet04}[b]
        (我说“伪”，是因为等式对于函数并未定义。)

        结合律在处理函数时相当明显，但在其他范畴中可能
        不那么明显。

  \item
        对于每个对象 $A$，都有一个箭头是组合的单位元。
        这个箭头从对象自身循环回自身。作为组合的单位元
        意味着，当它与任何以 $A$ 开始或以 $A$ 结束的箭头组合时，
        它会返回相同的箭头。对象 A 的单位箭头称为 $\idarrow[A]$ (\newterm{identity} on $A$，A 上的恒等)。在数学
        符号中，如果 $f$ 从 $A$ 到 $B$，那么
        \[f \circ \idarrow[A] = f\]
        并且
        \[\idarrow[B] \circ f = f\]
\end{enumerate}
在处理函数时，恒等箭头被实现为 identity function (恒等函数)，它只是返回其参数。
对于每种类型，其实现都是相同的，这意味着这个函数是
universally polymorphic (泛用多态) 的。在 C++ 中，我们可以将其定义为一个模板：

\begin{snip}{cpp}
template<class T> T id(T x) { return x; }
\end{snip}
当然，在 C++ 中没有什么是那么简单的，因为你不仅要考虑
你传递的是什么，还要考虑如何传递（即，按值、按引用、按 const 引用、按移动等等）。

在 Haskell 中，恒等函数是标准库（称为 Prelude）的一部分。这是它的声明和定义：

\src{snippet05}
如你所见，Haskell 中的多态函数是小菜一碟。在
声明中，你只需将类型替换为 type variable (类型变量)。这里的技巧是：具体类型 (concrete types) 的名称总是以大写字母开头，
类型变量的名称以小写字母开头。所以这里的
\code{a} 代表所有类型。

Haskell 函数定义由函数名后跟形式参数组成 —— 这里只有一个，\code{x}。函数体跟在等号后面。这种简洁性常常让
新手感到震惊，但你很快就会发现它非常有意义。函数
定义和函数调用是函数式编程的基础，所以它们的语法被简化到了
最低限度。不仅参数列表周围没有括号，而且参数之间也没有逗号
（稍后当我们定义多参数函数时你会看到）。

函数的主体总是一个表达式 —— 函数中没有语句。函数的结果就是这个表达式 ——
这里，只是 \code{x}。

这结束了我们的第二个 Haskell 课程。

恒等条件可以写成（再次，用伪 Haskell 代码）：

\src{snippet06}
你可能会问自己一个问题：为什么有人会费心去管
恒等函数 —— 一个什么都不做的函数？再说一次，为什么
我们要费心去管数字零呢？零是什么都没有的符号。古罗马人
有一个没有零的数字系统，他们能够建造
出色的道路和引水渠，其中一些至今仍然存在。

像零或 $\id$ 这样的中性值在处理
符号变量时非常有用。这就是为什么罗马人不太擅长
代数，而熟悉零概念的阿拉伯人和波斯人
却很擅长。因此，恒等函数作为 higher-order function (高阶函数) 的参数或返回值变得非常方便。高阶
函数使得函数的符号化操作成为可能。
它们是函数的代数。

总结一下：一个范畴由对象和箭头（态射）组成。
箭头可以组合，并且组合是结合的。每个对象
都有一个恒等箭头，作为组合下的单位元。

\section{组合是编程的本质}

函数式程序员有一种独特的处理问题的方式。他们
从提出非常具有禅意的问题开始。例如，在设计一个
交互式程序时，他们会问：什么是交互？在
实现康威生命游戏 (Conway's Game of Life) 时，他们可能会思考生命的意义。本着这种精神，我将要问：什么是编程？
在最基本的层面上，编程是关于告诉计算机做什么。“取内存地址 x 的内容并将其加到寄存器 EAX 的内容中。”但即使我们用 assembly (汇编) 编程，
我们给计算机的指令也是某种更有意义的东西的表达。我们在解决一个非平凡的问题（如果它是平凡的，我们就不需要计算机的帮助了）。我们如何解决问题？我们将大问题 decomposition (分解) 成小问题。如果小问题仍然太大，我们进一步分解它们，依此类推。最后，我们编写代码来解决所有小问题。然后就到了编程的本质：我们 compose (组合) 这些代码片段来创建更大问题的解决方案。如果我们不能把碎片重新组装起来，分解就没有意义了。

这种层级分解和 recomposition (重组) 的过程并非由计算机强加给我们。它反映了人类思维的局限性。我们的大脑一次只能处理少量概念。心理学中被引用最多的论文之一，
\urlref{http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two}{The Magical Number Seven, Plus or Minus Two} (神奇数字 7±2)，假定我们只能在头脑中保留 $7 \pm 2$ 个信息“块”。我们对人类 short-term memory (短期记忆) 的理解细节可能在变化，但我们确信它是有限的。底线是，我们无法处理对象的“汤”或代码的“意大利面条”。我们需要结构，不是因为结构良好的程序看起来令人愉悦，而是因为否则我们的大脑无法有效地处理它们。我们经常将某些代码描述为优雅或漂亮，但我们真正的意思是，它容易被我们有限的人类思维处理。优雅的代码创建的块大小恰到好处，数量也恰到好处，适合我们的思维消化系统吸收。

那么，用于程序组合的正确块是什么？它们的表面积必须比它们的体积增长得慢。（我喜欢这个类比，因为它符合直觉：几何对象的表面积与其大小的平方成正比增长——比体积慢，体积与其大小的立方成正比增长。）表面积是我们为了组合块所需的信息。体积是我们为了实现它们所需的信息。其思想是，一旦一个块被实现，我们就可以忘记其实现的细节，并专注于它如何与其他块交互。在 object-oriented programming (面向对象编程) 中，表面是对象的 class declaration (类声明)，或其 abstract interface (抽象接口)。在 functional programming (函数式编程) 中，它是函数的声明。（我稍微简化了事情，但大意如此。）

范畴论是极端的，因为它积极地阻止我们查看对象的内部。范畴论中的对象是一个抽象的、模糊的实体。你唯一能知道的就是它如何与其他对象相关——它如何通过箭头与它们连接。这就是互联网搜索引擎通过分析传入和传出链接来对网站进行排名的方式（除非它们作弊）。在面向对象编程中，理想化的对象仅通过其抽象接口可见（纯表面，无体积），其中 methods (方法) 扮演着箭头的角色。当你不得不深入研究对象的 implementation (实现) 以理解如何将其与其他对象组合的那一刻，你就失去了你的编程范式的优势。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        用你最喜欢的语言（或者第二喜欢的，如果你最喜欢的语言恰好是 Haskell），尽你所能地实现恒等函数。
  \item
        用你最喜欢的语言实现组合函数。它接受两个函数作为参数，并返回一个作为它们组合的函数。
  \item
        编写一个程序，尝试测试你的组合函数是否遵守恒等律。
  \item
        万维网 (world-wide web) 在任何意义上是一个范畴吗？链接是态射吗？
  \item
        Facebook 是一个范畴吗，以人为对象，以友谊为态射？
  \item
        何时一个 directed graph (有向图) 是一个范畴？
\end{enumerate}
