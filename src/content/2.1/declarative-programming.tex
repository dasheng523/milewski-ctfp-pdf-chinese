% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{在}{本书的第一部分}，我论证了范畴论和编程都关乎 composability (可组合性)。在编程中，你不断地分解问题，直到达到你可以处理的细节层次，然后依次解决每个子问题，并自底向上地重新组合解决方案。粗略地说，有两种方法可以做到这一点：通过告诉计算机要做什么，或者通过告诉它如何做。一种被称为 declarative (声明式)，另一种被称为 imperative (命令式)。

即使在最基础的层面上你也能看到这一点。组合本身可以被声明式地定义；例如，\code{h} 是 \code{g} 在 \code{f} 之后的复合：

\src{snippet01}
或者命令式地定义；例如，先调用 \code{f}，记住该调用的结果，然后用该结果调用 \code{g}：

\src{snippet02}
程序的命令式版本通常被描述为按时间顺序排列的一系列动作。特别是，对 \code{g} 的调用不能在 \code{f} 执行完成之前发生。至少，这是概念上的图景——在惰性语言中，使用 \emph{call-by-need} (按需调用) 的参数传递方式，实际执行可能会有所不同。

事实上，根据编译器的智能程度，声明式代码和命令式代码的执行方式可能几乎没有区别。但这两种方法论在解决问题的方式以及最终代码的可维护性和可测试性方面，有时会存在显著差异。

主要问题是：当面对一个问题时，我们是否总能在声明式和命令式方法之间做出选择来解决它？并且，如果存在声明式解决方案，它是否总能被翻译成计算机代码？这个问题的答案远非显而易见，如果我们能找到它，我们可能会彻底改变对宇宙的理解。

\begin{wrapfigure}{R}{0pt}
  \includegraphics[width=0.5\textwidth]{images/asteroids.png}
\end{wrapfigure}

让我详细说明一下。物理学中也存在类似的二元性，这要么指向某个深层的基础原理，要么告诉我们一些关于我们思维方式的东西。理查德·费曼 (Richard Feynman) 提到这种二元性是他研究量子电动力学 (quantum electrodynamics) 的灵感来源。

表达大多数物理定律有两种形式。一种使用 local (局部的) 或 infinitesimal (无穷小的) 考量。我们观察系统在一个小邻域周围的状态，并预测它在下一个瞬间将如何演化。这通常用 differential equations (微分方程) 来表达，这些方程必须在一个时间段内进行 integrate (积分) 或求和。

注意这种方法与命令式思维的相似之处：我们通过遵循一系列小步骤来达到最终解决方案，每一步都依赖于前一步的结果。事实上，物理系统的计算机模拟通常是通过将微分方程转化为差分方程并进行迭代来实现的。这就是“小行星”游戏中飞船动画的制作方式。在每个时间步长，飞船的位置通过加上一个小增量来改变，该增量是通过将其速度乘以时间增量来计算的。速度又通过一个与加速度成比例的小增量来改变，加速度由力除以质量给出。

这些是对应于 Newton's laws of motion (牛顿运动定律) 的微分方程的直接编码：
\begin{align*}
  F & = m \frac{dv}{dt} \\
  v & = \frac{dx}{dt}
\end{align*}
类似的方法可以应用于更复杂的问题，例如使用 Maxwell's equations (麦克斯韦方程组) 的电磁场传播，甚至使用 lattice \acronym{QCD} (格点 QCD (量子色动力学)) 的质子内部夸克和胶子的行为。

这种局部思维结合了由数字计算机所鼓励的空间和时间离散化，在斯蒂芬·沃尔夫勒姆 (Stephen Wolfram) 试图将整个宇宙的复杂性简化为 cellular automata (元胞自动机) 系统的英勇尝试中达到了极致。

另一种方法是 global (全局的)。我们观察系统的初始状态和最终状态，并通过最小化某个 functional (泛函) 来计算连接它们的轨迹。最简单的例子是 Fermat's principle of least time (费马最短时间原理)。它指出光线沿着使其传播时间最小化的路径传播。特别地，在没有反射或 refracting (折射) 物体的情况下，从点 $A$ 到点 $B$ 的光线将走最短路径，即直线。但是光在密集（透明）介质（如水或玻璃）中传播得更慢。因此，如果你在空气中选择起点，在水下选择终点，光线在空气中传播更长距离然后通过水走捷径会更有利。最小时间路径使光线在空气和水的边界处发生折射，从而产生 Snell's law (斯涅尔定律) of refraction (折射)：
\begin{equation*}
  \frac{sin(\theta_1)}{sin(\theta_2)} = \frac{v_1}{v_2}
\end{equation*}
其中 $v_1$ 是光在空气中的速度，$v_2$ 是光在水中的速度。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/snell.jpg}
\end{figure}

\noindent
所有的经典力学都可以从 the principle of least action (最小作用量原理) 推导出来。作用量可以通过对 Lagrangian (拉格朗日量)（即 kinetic energy (动能) 和 potential energy (势能) 之差——注意：是差而不是和，和是总能量）进行积分来计算任何轨迹的作用量。当你发射迫击炮击中给定目标时，炮弹会首先上升，到达重力势能较高的地方，并在那里停留一段时间，为作用量贡献负值。它也会在抛物线顶点减速，以最小化动能。然后它会加速以快速通过低势能区域。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/mortar.jpg}
\end{figure}

\noindent
费曼最大的贡献是认识到最小作用量原理可以推广到量子力学。在那里，问题再次根据初始状态和最终状态来表述。这些状态之间的 the Feynman path integral (费曼路径积分) 用于计算跃迁概率。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/feynman.jpg}
\end{figure}

\noindent
关键在于，我们描述物理定律的方式中存在一种奇特的、无法解释的二元性。我们可以使用局部的图景，其中事物按顺序以小增量发生。或者我们可以使用全局的图景，我们声明初始和最终条件，而中间的一切都随之确定。

全局方法也可以用于编程，例如在实现 ray tracing (光线追踪) 时。我们声明眼睛的位置和光源的位置，并找出光线可能连接它们的路径。我们没有明确地最小化每条光线的传播时间，但我们确实使用了斯涅尔定律和反射几何来达到同样的效果。

局部方法和全局方法之间最大的区别在于它们对空间，更重要的是对时间的处理方式。局部方法拥抱此时此地的即时满足感，而全局方法则采取长期的静态视角，仿佛未来早已注定，我们只是在分析某个永恒宇宙的属性。

这一点在 Functional Reactive Programming (\acronym{FRP}, 函数式反应编程) 处理用户交互的方法中得到了最好的体现。与为每个可能的用户操作编写单独的处理程序（所有处理程序都可以访问某个共享的 mutable state (可变状态)）不同，\acronym{FRP} 将外部事件视为一个 infinite list (无限列表)，并对其应用一系列转换。从概念上讲，我们所有未来操作的列表就在那里，作为我们程序的输入数据可用。从程序的角度来看，$\pi$ 的数字列表、伪随机数列表或通过计算机硬件传入的鼠标位置列表之间没有区别。在每种情况下，如果你想获得第 $n$ 项，你必须首先遍历前 $n-1$ 项。当应用于时间事件时，我们将此属性称为 \emph{causality} (因果性)。

那么这与 category theory (范畴论) 有什么关系呢？我认为范畴论鼓励全局方法，因此支持声明式编程。首先，与微积分不同，它没有内置的距离、邻域或时间概念。我们只有抽象的对象和它们之间的抽象连接。如果你可以通过一系列步骤从 $A$ 到达 $B$，你也可以一步到位。此外，范畴论的主要工具是 universal construction (泛构造)，它是全局方法的缩影。我们已经看到它在范畴积定义中的作用。它是通过指定其属性来完成的——一种非常声明式的方法。它是一个配备了两个 projections (投影) 的对象，并且是最好的此类对象——它优化了某个属性：因子分解其他此类对象的投影的属性。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productranking.jpg}
\end{figure}

\noindent
将此与费马最小时间原理或最小作用量原理进行比较。

反过来，将其与笛卡尔积的传统定义进行对比，后者更具命令式。你描述如何通过从一个集合中选择一个元素并从另一个集合中选择另一个元素来创建积的一个元素。这是一个创建 pair (序对) 的配方。还有另一个用于分解序对的配方。

在几乎所有的编程语言中，包括像 Haskell 这样的函数式语言，product types (积类型)、coproduct types (余积类型) 和 function types (函数类型) 都是内置的，而不是通过泛构造定义的；尽管有过创建 categorical programming languages (范畴式编程语言) 的尝试（例如，参见 \urlref{http://web.sfc.keio.ac.jp/~hagino/thesis.pdf}{Tatsuya Hagino 的论文}）。

无论是否直接使用，范畴定义都为预先存在的编程构造提供了理由，并催生了新的构造。最重要的是，范畴论提供了一种用于在声明式层面上推理计算机程序的 meta-language (元语言)。它还鼓励在将问题规范转化为代码之前对其进行推理。