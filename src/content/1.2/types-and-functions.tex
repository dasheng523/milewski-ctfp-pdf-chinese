% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{类}{型和函数的范畴}在编程中扮演着重要角色，所以让我们来谈谈什么是类型以及为什么我们需要它们。

\section{谁需要类型？}

关于 static (静态) vs. dynamic (动态) 以及 strong (强) vs. weak (弱) 类型各自的优势似乎存在一些争议。让我通过一个思想实验来说明这些选择。想象一下数百万只猴子坐在电脑键盘前，快乐地敲击着随机的按键，生成程序，编译并运行它们。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
使用 machine language (机器语言)，猴子们产生的任何字节组合都会被接受并运行。但对于更高级的语言，我们确实 appreciate (欣赏) 编译器能够检测词法和语法错误这一事实。许多猴子将得不到香蕉，但剩下的程序将更有可能是有用的。类型检查为无意义的程序提供了又一道屏障。此外，在 dynamically typed language (动态类型语言) 中，类型不匹配会在 runtime (运行时) 被发现，而在 strongly typed statically checked languages (强类型静态检查语言) 中，类型不匹配在 compile time (编译时) 被发现，从而在大量不正确的程序有机会运行之前就消除了它们。

所以问题是，我们是想让猴子开心，还是想生产正确的程序？

在打字猴子思想实验中，通常的目标是创作出莎士比亚全集。如果在流程中加入拼写检查器和语法检查器，将会大大提高成功的几率。类型检查器的类似物则更进一步，确保一旦罗密欧被声明为人类，他就不会长出叶子或在他强大的引力场中捕获光子。

\section{类型关乎可组合性}

Category theory (范畴论) 是关于组合箭头的。但并非任意两个箭头都可以组合。一个箭头的 target object (目标对象) 必须与下一个箭头的 source object (源对象) 相同。在编程中，我们将一个函数的结果传递给另一个函数。如果目标函数无法正确解释源函数产生的数据，程序将无法工作。两端必须匹配，组合才能生效。语言的 type system (类型系统) 越强，这种匹配就能被描述得越好，并能被机器更好地验证。

我听到的反对强静态类型检查的唯一严肃论点是，它可能会排除一些语义上正确的程序。实际上，这种情况极少发生，而且无论如何，每种语言都提供某种后门，在确实必要时绕过类型系统。即使是 Haskell 也有 \code{unsafeCoerce}。但这类工具应谨慎使用。弗朗茨·卡夫卡的角色格里高尔·萨姆沙在他蜕变成一只巨大的虫子时打破了类型系统，我们都知道结局如何。

我经常听到的另一个论点是，处理类型给程序员带来了过多的负担。在我自己写过几次 C++ 中的 iterator (迭代器) 声明之后，我本可以同情这种观点，但有一种叫做 \newterm{type inference} (类型推断) 的技术，它让编译器可以从类型被使用的上下文中推断出大部分类型。在 C++ 中，你现在可以将变量声明为 \code{auto}，让编译器找出它的类型。

在 Haskell 中，除了极少数情况，类型注解完全是可选的。程序员倾向于使用它们，因为它们能揭示代码的大量语义信息，并使编译错误更容易理解。在 Haskell 中，一个常见的做法是通过设计类型来开始一个项目。\sloppy{之后，类型注解驱动实现，并成为编译器强制执行的注释。}

强静态类型经常被用作不测试代码的借口。你有时可能会听到 Haskell 程序员说，“如果它能编译，那它一定是正确的。” 当然，并不能保证类型正确的程序在产生正确输出的意义上也是正确的。这种漫不经心态度的结果是，在几项研究中，Haskell 在代码质量方面并没有像人们预期的那样遥遥领先。似乎在商业环境中，修复错误的压力只被施加到某个特定的质量水平，这完全与软件开发的经济学和最终用户的容忍度有关，而与编程语言或方法论关系不大。一个更好的标准是衡量有多少项目落后于计划或交付时功能被大幅削减。

至于单元测试可以替代强类型的论点，考虑一下强类型语言中常见的 refactoring (重构) 实践：改变某个特定函数参数的类型。在强类型语言中，只需修改该函数的声明，然后修复所有编译中断即可。在弱类型语言中，一个函数现在期望不同数据这一事实无法传播到调用点。Unit testing (单元测试) 可能会捕获一些不匹配，但测试几乎总是一个概率性而非确定性的过程。测试是对证明的一种拙劣替代。

\section{什么是类型？}

关于类型最简单的直觉是它们是值的集合。类型 \code{Bool}（记住，具体类型在 Haskell 中以大写字母开头）是一个包含 \code{True} 和 \code{False} 两个元素的集合。类型 \code{Char} 是所有 Unicode 字符的集合，如 \code{a} 或 \code{ą}。

集合可以是有限的或无限的。类型 \code{String}，它是 \code{Char} 列表的同义词，是一个无限集合的例子。

当我们声明 \code{x} 是一个 \code{Integer} 时：

\src{snippet01}
我们是在说它是整数集合的一个元素。\code{Integer} 在 Haskell 中是一个无限集合，它可以用来进行任意精度的算术运算。还有一个有限集合 \code{Int}，它对应于机器类型，就像 C++ 的 \code{int}。

存在一些微妙之处使得将类型和集合等同起来有些棘手。涉及循环定义的多态函数存在问题，以及你不能拥有一个包含所有集合的集合；但正如我所承诺的，我不会在数学上过于拘泥细节。好消息是存在一个集合的范畴，称为 $\Set$，我们将直接使用它。在 $\Set$ 中，对象是集合，morphisms (态射)（箭头）是函数。

$\Set$ 是一个非常特殊的范畴，因为我们实际上可以窥视其对象的内部，并从中获得很多直觉。例如，我们知道空集没有任何元素。我们知道存在特殊的单元素集合。我们知道函数将一个集合的元素映射到另一个集合的元素。它们可以将两个元素映射到一个，但不能将一个元素映射到两个。我们知道 identity function (恒等函数) 将一个集合的每个元素映射到自身，等等。计划是逐渐忘记所有这些信息，转而用纯粹的范畴论术语，即用对象和箭头来表达所有这些概念。

在理想世界中，我们会说 Haskell 类型是集合，Haskell 函数是集合之间的数学函数。只有一个小问题：数学函数不执行任何代码——它只是知道答案。Haskell 函数必须计算答案。如果答案可以在有限步数内获得——无论这个数字有多大——这不是问题。但是有些计算涉及 recursion (递归)，这些计算可能永远不会终止。我们不能仅仅禁止 Haskell 中的不终止函数，因为区分终止和不终止函数是 undecidable (不可判定) 的——著名的 halting problem (停机问题)。这就是为什么计算机科学家想出了一个绝妙的主意，或者说一个主要的 hack (取巧)，取决于你的观点，即通过一个称为 \newterm{bottom} (底值) 的特殊值来扩展每个类型，表示为 \code{\_|\_}，或 Unicode $\bot$。这个“值”对应于一个永不终止的计算。所以一个声明为：

\src{snippet02}
的函数可能返回 \code{True}、\code{False} 或 \code{\_|\_}；后者意味着它永远不会终止。

有趣的是，一旦你接受了底值作为类型系统的一部分，将每个运行时错误视为底值，甚至允许函数显式返回底值，都是很方便的。后者通常通过表达式 \code{undefined} 来完成，例如：

\src{snippet03}
这个定义通过了类型检查，因为 \code{undefined} 求值为底值，它是任何类型（包括 \code{Bool}）的成员。你甚至可以写：

\src{snippet04}
（没有 \code{x}）因为底值也是类型 \code{Bool -> Bool} 的成员。

可能返回底值的函数称为 partial (偏函数)，相对于 total functions (全函数)，全函数对每个可能的参数都返回有效结果。

由于底值的存在，你会看到 Haskell 类型和函数的范畴被称为 $\Hask$ 而不是 $\Set$。从理论的角度来看，这是永无止境的复杂性的根源，所以在这一点上，我将使用我的屠夫刀，终止这条推理线。从实用的角度来看，忽略不终止的函数和底值，并将 $\Hask$ 视为真正的 $\Set$ 是可以的。\footnote{Nils Anders Danielsson, John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{Fast and Loose Reasoning is Morally Correct}。这篇论文为在大多数情况下忽略底值提供了理由。}

\section{为什么我们需要一个数学模型？}

作为一名程序员，你对你的编程语言的 syntax (语法) 和 grammar (文法) 非常熟悉。语言的这些方面通常在语言规范的开头就使用形式化表示法进行描述。但是语言的 meaning (意义)，或者说 semantics (语义)，则要难描述得多；它需要更多的篇幅，很少足够形式化，并且几乎从不完整。因此，语言律师之间永无止境的讨论，以及致力于阐释语言标准精妙之处的书籍形成了一个庞大的产业。

有描述语言语义的形式化工具，但是由于它们的复杂性，它们主要用于简化的学术语言，而不是现实生活中的编程庞然大物。其中一个称为 \newterm{operational semantics} (操作语义) 的工具描述了程序执行的机制。它定义了一个形式化的理想化 interpreter (解释器)。工业语言（如 C++）的语义通常使用非形式化的操作推理来描述，通常是借助一个 “abstract machine (抽象机器)” 的概念。

问题在于，使用操作语义来证明关于程序的性质非常困难。要证明一个程序的属性，你基本上必须通过理想化的解释器来“运行它”。

程序员从不执行形式化的 correctness proofs (正确性证明) 这一点并不重要。我们总是“认为”我们编写了正确的程序。没有人坐在键盘前说，“哦，我就随便写几行代码，看看会发生什么。” 我们认为我们编写的代码将执行某些操作，从而产生期望的结果。当它没有这样做时，我们通常会非常惊讶。这意味着我们确实对我们编写的程序进行推理，而且我们通常是通过在头脑中运行一个解释器来做到这一点的。只是要跟踪所有的变量真的很难。计算机擅长运行程序——人类不擅长！如果我们擅长，我们就不需要计算机了。

但是还有另一种选择。它被称为 \newterm{denotational semantics} (指称语义)，它基于数学。在指称语义中，每个编程构造都被赋予其数学解释。有了这个，如果你想证明一个程序的属性，你只需证明一个数学定理。你可能认为定理证明很难，但事实是，我们人类几千年来一直在建立数学方法，因此有大量的知识财富可以利用。而且，与专业数学家证明的那种定理相比，我们在编程中遇到的问题通常相当简单，甚至可以说是微不足道的。

考虑 Haskell 中 factorial (阶乘) 函数的定义，这是一种非常适合指称语义的语言：

\src{snippet05}
表达式 \code{{[}1..n{]}} 是从 \code{1} 到 \code{n} 的整数列表。函数 \code{product} 将列表的所有元素相乘。这就像从数学教科书中摘录的阶乘定义一样。将其与 C 语言比较：

\begin{snip}{c}
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
\end{snip}
我还需要多说什么吗？

好吧，我第一个承认这是一个廉价的伎俩！阶乘函数有一个明显的数学指称。敏锐的读者可能会问：从键盘读取字符或通过网络发送数据包的数学模型是什么？在很长一段时间里，这会是一个尴尬的问题，导致相当复杂的解释。似乎指称语义对于编写有用程序所必需的大量重要任务（这些任务可以很容易地通过操作语义处理）并不是最合适的。突破来自范畴论。Eugenio Moggi 发现 computational effect (计算效应) 可以映射到 monads (单子)。这被证明是一个重要的观察，不仅给指称语义带来了新的生机，使纯函数式程序更加可用，而且还为传统编程带来了新的启示。稍后，当我们发展更多的范畴论工具时，我会讨论单子。

拥有编程的数学模型的一个重要优势是，可以对软件进行形式化的正确性证明。当你编写消费者软件时，这可能看起来不那么重要，但在某些编程领域，失败的代价可能极其高昂，或者人命关天。但即使在为卫生系统编写 Web 应用程序时，你可能也会感激 Haskell 标准库中的函数和算法都带有正确性证明这一想法。

\section{纯函数与脏函数}

我们在 C++ 或任何其他 imperative language (命令式语言) 中称为函数的东西，与数学家所说的函数不是一回事。数学函数仅仅是值到值的映射。

我们可以在编程语言中实现一个数学函数：这样的函数，给定一个输入值，将计算出输出值。一个产生数字平方的函数可能会将输入值乘以自身。它每次被调用时都会这样做，并且保证每次使用相同的输入调用时都会产生相同的输出。一个数字的平方不会随着月相的变化而改变。

此外，计算一个数字的平方不应该有给你的狗分发美味零食的 side effect (副作用)。一个这样做的“函数”不能轻易地建模为数学函数。

在编程语言中，对于相同的输入总是产生相同结果并且没有副作用的函数称为 \newterm{pure functions} (纯函数)。在像 Haskell 这样的 pure functional language (纯函数式语言) 中，所有函数都是纯的。正因为如此，更容易为这些语言赋予指称语义并使用范畴论对其进行建模。至于其他语言，总是可以将自己限制在一个纯子集内，或者分开推理副作用。稍后我们将看到单子如何让我们仅使用纯函数来建模各种效应。所以我们通过将自己限制在数学函数上，实际上并没有失去任何东西。

\section{类型示例}

一旦你意识到类型是集合，你就可以想到一些相当奇特的类型。例如，对应于空集的类型是什么？不，它不是 C++ 的 \code{void}，尽管这个类型在 Haskell 中*确实*被称为 \code{Void}。这是一个没有任何值栖居的类型。你可以定义一个接受 \code{Void} 的函数，但你永远无法调用它。要调用它，你必须提供一个 \code{Void} 类型的值，而根本没有任何这样的值。至于这个函数可以返回什么，则没有任何限制。它可以返回任何类型（尽管它永远不会返回，因为它无法被调用）。换句话说，它是一个在返回类型上是 polymorphic (多态) 的函数。Haskell 程序员给它起了一个名字：

\src{snippet06}
（记住，\code{a} 是一个可以代表任何类型的类型变量。）这个名字并非偶然。在逻辑方面，类型和函数有更深的解释，称为 Curry-Howard isomorphism (Curry-Howard 同构)。类型 \code{Void} 代表假 (falsity)，而函数 \code{absurd} 的类型对应于“从假可以推导出任何事物”的陈述，正如拉丁格言 “ex falso sequitur quodlibet” 所言。

接下来是对应于 singleton set (单例集) 的类型。这是一个只有一个可能值的类型。这个值仅仅“存在”。你可能不会立刻认出它，但这就是 C++ 的 \code{void}。思考一下从此类型出发和到达此类型的函数。一个从 \code{void} 出发的函数总是可以被调用。如果它是一个纯函数，它将总是返回相同的结果。这里是这样一个函数的例子：

\begin{snip}{c}
int f44() { return 44; }
\end{snip}
你可能认为这个函数接受“无”，但正如我们刚刚看到的，一个接受“无”的函数永远无法被调用，因为没有代表“无”的值。那么这个函数接受什么呢？从概念上讲，它接受一个虚拟值，这个值永远只有一个实例，所以我们不必显式提及它。然而，在 Haskell 中，这个值有一个符号：一对空括号，\code{()}。所以，通过一个有趣的巧合（或者这是一个巧合吗？），在 C++ 和 Haskell 中调用 void 函数看起来是一样的。而且，由于 Haskell 对简洁的热爱，同样的符号 \code{()} 被用于类型、构造函数以及对应于单例集的唯一值。所以这是 Haskell 中的这个函数：

\src{snippet07}
第一行声明 \code{f44} 将类型 \code{()}，读作 “unit (单元类型)”，映射到类型 \code{Integer}。第二行通过模式匹配 unit 的唯一构造函数，即 \code{()}，来定义 \code{f44}，并产生数字 44。你可以通过提供 unit 值 \code{()} 来调用此函数：

\begin{snip}{c}
f44 ()
\end{snip}
注意，每个 unit 函数都等价于从目标类型中选择一个元素（这里是选择 \code{Integer} 44）。实际上，你可以将 \code{f44} 视为数字 44 的不同表示。这是一个例子，说明我们如何通过讨论函数（箭头）来代替显式提及集合的元素。从 unit 到任何类型 $A$ 的函数与该集合 $A$ 的元素一一对应。

那么返回类型为 \code{void} 的函数呢，或者在 Haskell 中，返回类型为 unit 的函数？在 C++ 中，这类函数用于副作用，但我们知道这些在数学意义上不是真正的函数。一个返回 unit 的纯函数什么也不做：它丢弃它的参数。

数学上，从集合 $A$ 到单例集的函数将 $A$ 的每个元素映射到该单例集的唯一元素。对于每个 $A$，都恰好存在一个这样的函数。这是 \code{Integer} 的这个函数：

\src{snippet08}
你给它任何整数，它都返回给你一个 unit。本着简洁的精神，Haskell 允许你对被丢弃的参数使用通配符模式，即下划线。这样你就不必为它起名字了。所以上面可以重写为：

\src{snippet09}
注意，这个函数的实现不仅不依赖于传递给它的值，甚至不依赖于参数的类型。

可以用相同公式为任何类型实现的函数称为 parametrically polymorphic (参数多态)。你可以使用类型参数而不是具体类型，用一个方程实现一整族这样的函数。我们应该如何称呼一个从任何类型到 unit 类型的多态函数？当然我们会称它为 \code{unit}：

\src{snippet10}
在 C++ 中，你会这样写这个函数：

\begin{snip}{cpp}
template<class T>
void unit(T) {}
\end{snip}
类型谱系中的下一个是二元集。在 C++ 中它被称为 \code{bool}，而在 Haskell 中，可以预见地，称为 \code{Bool}。区别在于，在 C++ 中 \code{bool} 是一个内置类型，而在 Haskell 中，它可以定义如下：

\src{snippet11}
（解读这个定义的方式是 \code{Bool} 要么是 \code{True} 要么是 \code{False}。）原则上，也应该能够在 C++ 中将布尔类型定义为枚举：

\begin{snip}{cpp}
enum bool {
    true,
    false
};
\end{snip}
但是 C++ 的 \code{enum} 秘密地是一个整数。本可以使用 C++11 的 “\code{enum class}”，但是那样你就必须用类名来限定它的值，如 \code{bool::true} 和 \code{bool::false}，更不用说必须在每个使用它的文件中包含相应的头文件了。

从 \code{Bool} 出发的纯函数只是从目标类型中选择两个值，一个对应于 \code{True}，另一个对应于 \code{False}。

到 \code{Bool} 的函数称为 \newterm{predicates} (谓词)。例如，Haskell 库 \code{Data.Char} 充满了像 \code{isAlpha} 或 \code{isDigit} 这样的谓词。在 C++ 中有一个类似的库 \code{} 定义了，除其他外，\code{isalpha} 和 \code{isdigit}，但这些返回一个 \code{int} 而不是布尔值。实际的谓词定义在 \code{std::ctype} 中，形式为 \code{ctype::is(alpha, c)}、\code{ctype::is(digit, c)} 等。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        用你最喜欢的语言定义一个 higher-order function (高阶函数)（或 function object (函数对象)）\code{memoize}。这个函数接受一个纯函数 \code{f} 作为参数，并返回一个行为几乎与 \code{f} 完全相同的函数，不同之处在于它对每个参数只调用原始函数一次，将结果内部存储起来，并在后续使用相同参数调用时返回这个存储的结果。你可以通过观察其性能来区分 memoized (记忆化) 的函数和原始函数。例如，尝试记忆化一个需要很长时间来求值的函数。第一次调用它时，你需要等待结果，但在后续使用相同参数调用时，你应该能立即得到结果。
  \item
        尝试记忆化你标准库中通常用来产生随机数的函数。它能工作吗？
  \item
        大多数随机数生成器可以用一个 seed (种子) 来初始化。实现一个函数，它接受一个种子，用该种子调用随机数生成器，并返回结果。记忆化该函数。它能工作吗？
  \item
        以下哪些 C++ 函数是纯函数？尝试记忆化它们，并观察当你多次调用它们时（记忆化的和非记忆化的）会发生什么：

        \begin{enumerate}
          \tightlist
          \item
                文中示例的阶乘函数。
          \item
                \begin{minted}{cpp}
std::getchar()
\end{minted}
          \item
                \begin{minted}{cpp}
bool f() {
    std::cout << "Hello!" << std::endl;
    return true;
}
\end{minted}
          \item
                \begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
\end{minted}
        \end{enumerate}
  \item
        从 \code{Bool} 到 \code{Bool} 有多少个不同的函数？你能全部实现它们吗？
  \item
        画一个范畴的图，其唯一的对象是类型 \code{Void}、\code{()} (unit) 和 \code{Bool}；箭头对应于这些类型之间所有可能的函数。用函数名标记箭头。
\end{enumerate}