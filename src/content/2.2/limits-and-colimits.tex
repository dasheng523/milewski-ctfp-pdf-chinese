% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{在}{范畴论中似乎} 万事万物皆相互关联，并且可以从多个角度来看待。以 \hyperref[products-and-coproducts]{product (积)} 的 universal construction (泛构造) 为例。既然我们对 \hyperref[functors]{functors (函子)} 和 \hyperref[natural-transformations]{natural transformations (自然变换)} 有了更多了解，我们能否简化并可能推广它呢？让我们试试。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{images/productpattern.jpg}
\end{figure}

\noindent
积的构造始于选择两个对象 $a$ 和 $b$，我们要构造它们的积。但 \emph{选择对象} 是什么意思？我们能否用更范畴化的术语来重新表述这个动作？两个对象构成一个模式——一个非常简单的模式。我们可以将这个模式抽象为一个 category (范畴)——一个非常简单的范畴，但仍然是一个范畴。我们将这个范畴称为 $\cat{2}$。它只包含两个对象，$1$ 和 $2$，除了两个必须的 identity morphisms (单位态射) 外没有其他 morphisms (态射)。现在我们可以将选择 $\cat{C}$ 中的两个对象重新表述为定义一个从范畴 $\cat{2}$ 到 $\cat{C}$ 的函子 $D$ 的行为。函子将对象映射到对象，所以它的像只是两个对象（如果函子坍缩了对象，也可能是一个对象，那也没关系）。它也映射态射——在这种情况下，它只是将单位态射映射到单位态射。

这种方法的好处在于它建立在范畴概念之上，避开了像“选择对象”这样不精确的描述，这些描述直接取自我们祖先的狩猎采集词汇。而且，顺便说一句，它也很容易推广，因为没有什么能阻止我们使用比 $\cat{2}$ 更复杂的范畴来定义我们的模式。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/two.jpg}
\end{figure}

\noindent
但让我们继续。积定义的下一步是选择候选对象 $c$。这里我们同样可以将选择重新表述为从 singleton category (单例范畴) 出发的函子。确实，如果我们使用 Kan extensions (Kan 扩张)，那将是正确的做法。但由于我们还没准备好讨论 Kan 扩张，我们可以使用另一个技巧：一个从同一个范畴 $\cat{2}$ 到 $\cat{C}$ 的 constant functor (常函子) $\Delta$。选择 $\cat{C}$ 中的 $c$ 可以通过 $\Delta_c$ 来完成。记住，$\Delta_c$ 将所有对象映射到 $c$，并将所有态射映射到 $\idarrow[c]$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/twodelta.jpg}
\end{figure}

\noindent
现在我们有两个函子，$\Delta_c$ 和 $D$，它们都从 $\cat{2}$ 映到 $\cat{C}$，所以很自然地会问它们之间是否存在自然变换。由于 $\cat{2}$ 中只有两个对象，一个自然变换将有两个 components (分量)。$\cat{2}$ 中的对象 $1$ 被 $\Delta_c$ 映射到 $c$，被 $D$ 映射到 $a$。因此，$\Delta_c$ 和 $D$ 之间在 $1$ 处的一个自然变换的分量是从 $c$ 到 $a$ 的一个态射。我们可以称之为 $p$。类似地，第二个分量是从 $c$ 到 $b$ 的一个态射 $q$——$b$ 是 $\cat{2}$ 中对象 $2$ 在 $D$ 下的像。但这些恰好就像我们原始积定义中使用的两个 projections (投影)。所以与其谈论选择对象和投影，我们可以只谈论选择函子和自然变换。恰好在这个简单的例子中，我们变换的 naturality condition (自然性条件) 是平凡满足的，因为 $\cat{2}$ 中没有（除了单位态射之外的）态射。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productcone.jpg}
\end{figure}

\noindent
将此构造推广到 $\cat{2}$ 之外的范畴——例如，包含非平凡态射的范畴——将对 $\Delta_c$ 和 $D$ 之间的变换施加自然性条件。我们称这样的变换为 \emph{cone} (锥)，因为 $\Delta$ 的像是锥/棱锥的 apex (顶点)，其侧面由自然变换的分量构成。$D$ 的像构成了锥的底。

通常，要构建一个锥，我们从一个定义模式的范畴 $\cat{I}$ 开始。它是一个小的，通常是有限的范畴。我们选择一个从 $\cat{I}$ 到 $\cat{C}$ 的函子 $D$，并称其（或其像）为 \emph{diagram} (图表)。我们选择 $\cat{C}$ 中的某个 $c$ 作为我们锥的顶点。我们用它来定义从 $\cat{I}$ 到 $\cat{C}$ 的常函子 $\Delta_c$。那么从 $\Delta_c$ 到 $D$ 的自然变换就是我们的锥。对于有限的 $\cat{I}$，它只是一组连接 $c$ 到图表的态射：$\cat{I}$ 在 $D$ 下的像。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/cone.jpg}
\end{figure}

\noindent
自然性要求此图表中的所有三角形（棱锥的侧面）都 commute (交换)。确实，取 $\cat{I}$ 中的任何态射 $f$。函子 $D$ 将其映射到 $\cat{C}$ 中的态射 $D f$，这个态射构成了某个三角形的底。常函子 $\Delta_c$ 将 $f$ 映射到 $c$ 上的单位态射。$\Delta$ 将态射的两端挤压到一个对象中，自然性方图变成了一个交换三角形。这个三角形的两臂是自然变换的分量。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/conenaturality.jpg}
\end{figure}

\noindent
所以这是一个锥。我们感兴趣的是 \newterm{universal cone} (泛锥)——就像我们为积的定义选择了一个泛对象一样。

有多种方法可以做到这一点。例如，我们可以基于给定的函子 $D$ 定义一个 \emph{category of cones} (锥的范畴)。该范畴中的对象是锥。然而，并非 $\cat{C}$ 中的每个对象 $c$ 都能成为锥的顶点，因为 $\Delta_c$ 和 $D$ 之间可能不存在自然变换。

为了使其成为一个范畴，我们还必须定义锥之间的态射。这些态射将完全由它们顶点之间的态射决定。但并非任何态射都可以。回想一下，在我们构造积时，我们施加了条件，即候选对象（顶点）之间的态射必须是投影的公共因子。例如：

\src{snippet01}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/productranking.jpg}
\end{figure}

这个条件在一般情况下转化为以下条件：其一边是 factorizing morphism (分解态射) 的所有三角形都必须交换。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/conecommutativity.jpg}
  \caption{连接两个锥的交换三角形，带有分解态射 $h$（这里，下方的锥是泛锥，其顶点为 $\Lim[D]$）}
\end{figure}

\noindent
我们将采用那些分解态射作为我们锥范畴中的态射。很容易检查这些态射确实可以复合，并且单位态射也是一个分解态射。因此，锥构成一个范畴。

现在我们可以将泛锥定义为锥范畴中的 \emph{terminal object} (终结对象)。终结对象的定义指出，从任何其他对象到该对象存在唯一的态射。在我们的例子中，这意味着从任何其他锥的顶点到泛锥的顶点存在唯一的分解态射。我们称这个泛锥为图表 $D$ 的 \emph{limit} (极限)，记为 $\Lim[D]$（在文献中，你经常会看到 $\Lim$ 符号下有一个指向 $I$ 的左箭头）。通常，作为简写，我们将这个锥的顶点称为极限（或极限对象）。

其直觉是，极限在单个对象中体现了整个图表的属性。例如，我们双对象图表的极限是两个对象的积。积（连同两个投影）包含了关于这两个对象的信息。并且作为泛对象意味着它没有多余的冗余信息。

\section{作为自然同构的极限}

这个极限的定义仍然有些不令人满意。我的意思是，它是可行的，但我们仍然有连接任意两个锥的三角形必须交换的这个条件。如果我们能用某个自然性条件来替换它，那该多优雅啊。但是如何做呢？

我们不再处理单个锥，而是处理一整个锥的集合（实际上是一个范畴）。如果极限存在（并且——明确地说——不能保证它存在），那么其中一个锥就是泛锥。对于每个其他的锥，我们都有一个唯一的分解态射，将其顶点（称之为 $c$）映射到泛锥的顶点（我们命名为 $\Lim[D]$）。（事实上，我可以省略“其他”这个词，因为单位态射将泛锥映射到自身，并且它平凡地通过自身分解。）让我重复一下重要的部分：给定任何锥，存在一个唯一的特殊类型的态射。我们有一个从锥到特殊态射的映射，并且它是一一对应的。

这个特殊态射是 hom-set (态射集合) $\cat{C}(c, \Lim[D])$ 的一个成员。该态射集合的其他成员则没有那么幸运，因为它们不能分解这两个锥的映射。我们想要的是能够为每个 $c$ 从集合 $\cat{C}(c, \Lim[D])$ 中挑选一个态射——一个满足特定交换性条件的态射。这听起来像是在定义一个自然变换吗？确实如此！

但是这个变换关联的函子是什么呢？

一个函子是将 $c$ 映射到集合 $\cat{C}(c, \Lim[D])$。它是一个从 $\cat{C}$ 到 $\Set$ 的函子——它将对象映射到集合。实际上它是一个 contravariant functor (逆变函子)。下面我们定义它在态射上的作用：取一个从 $c'$ 到 $c$ 的态射 $f$：
\[f \Colon c' \to c\]
我们的函子将 $c'$ 映射到集合 $\cat{C}(c', \Lim[D])$。为了定义这个函子在 $f$ 上的作用（换句话说，提升 $f$），我们必须定义 $\cat{C}(c, \Lim[D])$ 和 $\cat{C}(c', \Lim[D])$ 之间的相应映射。那么让我们选取 $\cat{C}(c, \Lim[D])$ 的一个元素 $u$，看看是否能将其映射到 $\cat{C}(c', \Lim[D])$ 的某个元素。态射集合的元素是一个态射，所以我们有：
\[u \Colon c \to \Lim[D]\]
我们可以用 $f$ 前复合 $u$ 得到：
\[u \circ f \Colon c' \to \Lim[D]\]
这就是 $\cat{C}(c', \Lim[D])$ 的一个元素——所以确实，我们找到了态射的映射：

\src{snippet02}
注意 $c$ 和 $c'$ 顺序的反转，这是 \emph{逆变} 函子的特征。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/homsetmapping.jpg}
\end{figure}

\noindent
要定义自然变换，我们需要另一个也是从 $\cat{C}$ 到 $\Set$ 的映射的函子。但这次我们将考虑一个锥的集合。锥只是自然变换，所以我们关注的是自然变换的集合 $\mathit{Nat}(\Delta_c, D)$。从 $c$ 到这个特定自然变换集合的映射是一个（逆变）函子。我们如何证明这一点？同样，让我们定义它在一个态射上的作用：
\[f \Colon c' \to c\]
$f$ 的提升应该是两个从 $\cat{I}$ 到 $\cat{C}$ 的函子之间自然变换的映射：
\[\mathit{Nat}(\Delta_c, D) \to \mathit{Nat}(\Delta_{c'}, D)\]
我们如何映射自然变换？每个自然变换都是态射的选择——它的分量——$\cat{I}$ 的每个元素对应一个态射。某个 $\alpha$（$\mathit{Nat}(\Delta_c, D)$ 的成员）在 $a$（$\cat{I}$ 中的一个对象）处的分量是一个态射：
\[\alpha_a \Colon \Delta_c a \to D a\]
或者，使用常函子 $\Delta$ 的定义，
\[\alpha_a \Colon c \to D a\]
给定 $f$ 和 $\alpha$，我们必须构造一个 $\beta$，它是 $\mathit{Nat}(\Delta_{c'}, D)$ 的成员。它在 $a$ 处的分量应该是一个态射：
\[\beta_a \Colon c' \to D a\]
我们可以很容易地通过用 $f$ 前复合前者 ($\alpha_a$) 来得到后者 ($\beta_a$)：
\[\beta_a = \alpha_a \circ f\]
相对容易证明这些分量确实构成了一个自然变换。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/natmapping.jpg}
\end{figure}

\noindent
给定我们的态射 $f$，我们从而按分量构建了两个自然变换之间的映射。这个映射为函子定义了 \code{contramap}：
\[c \to \mathit{Nat}(\Delta_c, D)\]
我刚才所做的就是向你展示我们有两个从 $\cat{C}$ 到 $\Set$ 的（逆变）函子。我没有做任何假设——这些函子总是存在的。

顺便提一下，这些函子中的第一个在范畴论中扮演着重要角色，我们将在讨论米田引理时再次看到它。从任何范畴 $\cat{C}$ 到 $\Set$ 的逆变函子有一个名字：它们被称为 "presheaves" (预层)。这个被称为 \newterm{representable presheaf} (可表示预层)。第二个函子也是一个预层。

现在我们有了两个函子，我们可以讨论它们之间的自然变换了。所以，不再赘述，结论如下：当且仅当我刚刚定义的两个函子之间存在 natural isomorphism (自然同构) 时，从 $\cat{I}$ 到 $\cat{C}$ 的函子 $D$ 具有极限 $\Lim[D]$：
\[\cat{C}(c, \Lim[D]) \simeq \mathit{Nat}(\Delta_c, D)\]
让我提醒你什么是自然同构。它是一个自然变换，其每个分量都是一个 isomorphism (同构)，也就是说是一个可逆态射。

我不会详细证明这个陈述。过程相当直接， وإن لم يكن مملاً (although not tedious)。在处理自然变换时，你通常关注分量，它们是态射。在这种情况下，由于两个函子的目标都是 $\Set$，自然同构的分量将是函数。这些是高阶函数，因为它们从态射集合映到自然变换集合。同样，你可以通过考虑函数对其参数的作用来分析它：这里的参数将是一个态射——$\cat{C}(c, \Lim[D])$ 的成员——结果将是一个自然变换——$\mathit{Nat}(\Delta_c, D)$ 的成员，或者我们称之为锥。这个自然变换，反过来，有它自己的分量，它们是态射。所以一路下来都是态射，如果你能跟踪它们，你就能证明这个陈述。

最重要的结果是，这个同构的自然性条件恰好就是锥映射的交换性条件。

作为后续内容的预告，让我提一下集合 $\mathit{Nat}(\Delta_c, D)$ 可以被认为是函子范畴中的一个态射集合；所以我们的自然同构关联了两个态射集合，这指向了一个更一般的关系，称为 adjunction (伴随)。

\section{极限的例子}

我们已经看到范畴积是由我们称为 $\cat{2}$ 的简单范畴生成的图表的极限。

还有一个更简单的极限例子：terminal object (终结对象)。第一反应可能会认为单例范畴会导致终结对象，但事实甚至更简单：终结对象是由 empty category (空范畴) 生成的极限。来自空范畴的函子不选择任何对象，所以锥缩小到只剩下顶点。泛锥是那个唯一的顶点，它有来自任何其他顶点的唯一态射指向它。你会认出这就是终结对象的定义。

下一个有趣的极限称为 \emph{equalizer} (等化子)。它是由一个包含两个元素以及它们之间两个平行态射（以及像往常一样的单位态射）的双元素范畴生成的极限。这个范畴在 $\cat{C}$ 中选择一个由两个对象 $a$ 和 $b$ 以及两个态射组成的图表：

\src{snippet03}

要在此图表上构建一个锥，我们必须添加顶点 $c$ 和两个投影：

\src{snippet04}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/equalizercone.jpg}
\end{figure}

\noindent
我们有两个必须交换的三角形：

\src{snippet05}

这告诉我们 $q$ 由其中一个方程唯一确定，比如 \code{q = f . p}，我们可以将其从图中省略。所以我们只剩下一个条件：

\src{snippet06}

思考它的方式是，如果我们将注意力限制在 $\Set$ 上，函数 $p$ 的像选择了 $a$ 的一个子集。当限制在这个子集上时，函数 $f$ 和 $g$ 是相等的。

例如，取 $a$ 为由坐标 $x$ 和 $y$ 参数化的二维平面。取 $b$ 为实数线，并取：

\src{snippet07}

这两个函数的等化子是实数集合（顶点 $c$）和函数：

\src{snippet08}

注意 $(p~t)$ 在二维平面中定义了一条直线。沿着这条直线，这两个函数是相等的。

当然，还有其他的集合 $c'$ 和函数 $p'$ 可能导致相等：

\src{snippet09}

但它们都通过 $p$ 唯一地分解出来。例如，我们可以取 singleton set (单例集) $\cat{()}$ 作为 $c'$ 和函数：

\src{snippet10}

这是一个好的锥，因为 $f (0, 0) = g (0, 0)$。但它不是泛锥，因为存在通过 $h$ 的唯一分解：

\src{snippet11}

其中

\src{snippet12}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/equilizerlimit.jpg}
\end{figure}

\noindent
因此，等化子可以用来解形如 $f~x = g~x$ 的方程。但它更通用，因为它是根据对象和态射而不是代数来定义的。

另一个更普遍的解方程思想体现在另一个极限中——the pullback (拉回)。在这里，我们仍然有两个我们想要等同的态射，但这次它们的 domains (域) 不同。我们从一个形状为 $1\rightarrow2\leftarrow3$ 的三对象范畴开始。对应于这个范畴的图表由三个对象 $a$、 $b$ 和 $c$ 以及两个态射组成：

\src{snippet13}

这个图表通常被称为 \emph{cospan} (余对径)。

构建在此图表之上的锥由顶点 $d$ 和三个态射组成：

\src{snippet14}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pullbackcone.jpg}
\end{figure}

\noindent
交换性条件告诉我们 $r$ 完全由其他态射确定，可以从图中省略。所以我们只剩下以下条件：

\src{snippet15}
拉回是这种形状的泛锥。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/pullbacklimit.jpg}
\end{figure}

\noindent
同样，如果你将焦点缩小到集合上，你可以认为对象 $d$ 由来自 $a$ 和 $c$ 的元素对组成，对于这些元素对，$f$ 作用于第一个分量等于 $g$ 作用于第二个分量。如果这仍然太笼统，考虑 $g$ 是常数函数的特殊情况，比如说 $g~\_ = 1.23$（假设 $b$ 是实数集）。那么你实际上是在解方程：

\src{snippet16}

在这种情况下，$c$ 的选择无关紧要（只要它不是空集），所以我们可以取它为单例集。集合 $a$ 可以是，例如，三维向量的集合，而 $f$ 是向量长度。那么拉回就是形如 $(v, ())$ 的序对集合，其中 $v$ 是长度为 1.23 的向量（方程 $\sqrt{(x^{2}+y^{2}+z^{2})} = 1.23$ 的解），而 $()$ 是单例集的虚拟元素。

但是拉回有更广泛的应用，在编程中也是如此。例如，考虑 C++ 类作为一个范畴，其中态射是连接子类到超类的箭头。我们将认为继承是 transitive property (传递性) 的，所以如果 \code{C} 继承自 \code{B} 并且 \code{B} 继承自 \code{A}，那么我们将说 \code{C} 继承自 \code{A}（毕竟，你可以在期望 \code{A} 指针的地方传递 \code{C} 指针）。而且，我们将假设 \code{C} 继承自 \code{C}，所以每个类都有单位箭头。这样，子类化就与子类型化保持一致。C++ 也支持 multiple inheritance (多重继承)，所以你可以构造一个菱形继承图，其中两个类 \code{B} 和 \code{C} 继承自 \code{A}，第四个类 \code{D} 多重继承自 \code{B} 和 \code{C}。通常情况下，\code{D} 会得到 \code{A} 的两个副本，这很少是期望的；但是你可以使用 virtual inheritance (虚继承) 来让 \code{D} 中只有一份 \code{A} 的副本。

在这个图表中让 \code{D} 成为拉回意味着什么？这意味着任何多重继承自 \code{B} 和 \code{C} 的类 \code{E} 也是 \code{D} 的子类。这在 C++ 中不能直接表达，因为 C++ 的子类型化是 nominal (名义化的)（C++ 编译器不会推断这种类关系——它需要“duck typing (鸭子类型)”）。但是我们可以跳出子类型关系，转而询问从 \code{E} 到 \code{D} 的转换是否安全。如果 \code{D} 是 \code{B} 和 \code{C} 的最基本组合，没有额外的数据，也没有覆盖方法，那么这种转换将是安全的。当然，如果 \code{B} 和 \code{C} 的某些方法之间存在名称冲突，就不会有拉回。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.25\textwidth]{images/classes.jpg}
\end{figure}

\noindent
拉回在 type inference (类型推断) 中也有更高级的用途。通常需要 \emph{unify} (合一) 两个表达式的类型。例如，假设编译器想要推断一个函数的类型：

\begin{snip}{haskell}
twice f x = f (f x)
\end{snip}
它会为所有变量和子表达式分配初步类型。特别是，它会分配：

\begin{snip}{haskell}
f       :: t0
x       :: t1
f x     :: t2
f (f x) :: t3
\end{snip}
由此它将推断出：

\begin{snip}{haskell}
twice :: t0 -> t1 -> t3
\end{snip}
它还会根据函数应用规则提出一组约束：

\begin{snip}{haskell}
t0 = t1 -> t2 -- 因为 f 应用于 x
t0 = t2 -> t3 -- 因为 f 应用于 (f x)
\end{snip}
这些约束必须通过找到一组类型（或类型变量）来合一，当将它们替换到两个表达式中的未知类型时，产生相同的类型。一种这样的替换是：

\begin{snip}{haskell}
t1 = t2 = t3 = Int
twice :: (Int -> Int) -> Int -> Int
\end{snip}
但是，显然，它不是最通用的。最通用的替换是使用拉回获得的。我不会深入细节，因为它们超出了本书的范围，但你可以说服自己结果应该是：

\begin{snip}{haskell}
twice :: (t -> t) -> t -> t
\end{snip}
其中 \code{t} 是一个自由类型变量。

\section{余极限}

就像范畴论中的所有构造一样，极限在对偶范畴中有它们的对偶镜像。当你反转锥中所有箭头的方向时，你会得到一个 co-cone (余锥)，其中的泛锥被称为 colimit (余极限)。注意，反转也影响分解态射，它现在从泛余锥流向任何其他余锥。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/colimit.jpg}
  \caption{带有连接两个顶点的分解态射 $h$ 的余锥。}
\end{figure}

\noindent
余极限的一个典型例子是 coproduct (余积)，它对应于由 $\cat{2}$（我们在积定义中使用的范畴）生成的图表。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{images/coproductranking.jpg}
\end{figure}

\noindent
积和余积都体现了一对对象的本质，只是方式不同。

就像终结对象是极限一样，initial object (初始对象) 是对应于基于空范畴的图表的余极限。

拉回的对偶称为 \emph{pushout} (推出)。它基于一个称为 span (对径) 的图表，由范畴 $1\leftarrow2\rightarrow3$ 生成。

\section{连续性}

我之前说过，函子接近于范畴的 continuous mappings (连续映射) 的思想，因为它们从不破坏现有的连接（态射）。\emph{continuous functor} (连续函子) $F$ 从范畴 $\cat{C}$ 到 $\cat{C'}$ 的实际定义包括函子保持极限的要求。$\cat{C}$ 中的每个图表 $D$ 都可以通过简单地复合两个函子映射到 $\cat{C'}$ 中的图表 $F \circ D$。$F$ 的 continuity (连续性) 条件表明，如果图表 $D$ 有极限 $\Lim[D]$，那么图表 $F \circ D$ 也有极限，并且它等于 $F (\Lim[D])$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{images/continuity.jpg}
\end{figure}

\noindent
注意，因为函子将态射映射到态射，将复合映射到复合，所以锥的像总是一个锥。交换三角形总是被映射到交换三角形（函子保持复合）。分解态射也是如此：分解态射的像也是一个分解态射。所以每个函子都\emph{几乎}是连续的。可能出错的是唯一性条件。$\cat{C'}$ 中的分解态射可能不是唯一的。$\cat{C'}$ 中也可能存在其他在 $\cat{C}$ 中不存在的“更好的锥”。

hom-functor (Hom 函子) 是连续函子的一个例子。回想一下，Hom 函子 $\cat{C}(a, b)$ 在第一个变量上是逆变的，在第二个变量上是协变的。换句话说，它是一个函子：
\[\cat{C}^\mathit{op} \times \cat{C} \to \Set\]
当其第二个参数固定时，Hom 集合函子（变成了可表示预层）将 $\cat{C}$ 中的余极限映射到 $\Set$ 中的极限；当其第一个参数固定时，它将极限映射到极限。

在 Haskell 中，Hom 函子是将任意两个类型映射到函数类型的映射，所以它只是一个参数化的函数类型。当我们固定第二个参数时，比如说固定为 \code{String}，我们得到逆变函子：

\src{snippet17}
连续性意味着当 \code{ToString} 应用于一个余极限，例如余积 \code{Either b c} 时，它将产生一个极限；在这种情况下是两个函数类型的积：

\src{snippet18}
确实，任何 \code{Either b c} 的函数都是通过一个 case 语句实现的，两种情况由一对函数来处理。

类似地，当我们固定 Hom 集合的第一个参数时，我们得到熟悉的 reader 函子。它的连续性意味着，例如，任何返回积的函数等价于函数的积；特别是：

\src{snippet19}
我知道你在想什么：你不需要范畴论来弄清楚这些事情。你是对的！尽管如此，我仍然觉得这些结果可以从第一原理推导出来，而无需借助位和字节、处理器架构、编译器技术，甚至 lambda 演算，这真是令人惊奇。

如果你好奇“极限”和“连续性”这两个名字的来源，它们是微积分中相应概念的推广。在微积分中，极限和连续性是根据开邻域定义的。定义拓扑的开集构成一个范畴（一个 poset (偏序集)）。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        你将如何在 C++ 类的范畴中描述一个 pushout (推出)？
  \item
        证明 identity functor (恒等函子) $\mathbf{Id} \Colon \cat{C} \to \cat{C}$ 的极限是 initial object (初始对象)。
  \item
        给定集合的子集构成一个范畴。该范畴中的态射被定义为连接两个集合的箭头，如果第一个集合是第二个集合的子集。在这个范畴中，两个集合的 pullback (拉回) 是什么？pushout (推出) 是什么？初始对象和终结对象是什么？
  \item
        你能猜到 coequalizer (余等化子) 是什么吗？
  \item
        证明，在一个具有终结对象的范畴中，朝向终结对象的拉回是 product (积)。
  \item
        类似地，证明从初始对象（如果存在）出发的推出是 coproduct (余积)。
\end{enumerate}