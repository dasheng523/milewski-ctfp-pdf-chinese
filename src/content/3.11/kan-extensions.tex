% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{到}{目前为止，我们}主要是在处理单个范畴 (category) 或一对范畴。在某些情况下，这有点过于约束。

例如，在范畴 $\cat{C}$ 中定义极限 (limit) 时，我们引入了一个索引范畴 (index category) $\cat{I}$ 作为构成我们锥 (cones) 底部的模式模板。引入另一个平凡的范畴来作为锥的顶点 (apex) 模板本来是有意义的。但我们当时使用了从 $\cat{I}$ 到 $\cat{C}$ 的常函子 (constant functor) $\Delta_c$。

现在是时候修正这种不便了。让我们使用三个范畴来定义极限。从索引范畴 $\cat{I}$ 到 $\cat{C}$ 的函子 (functor) $D$ 开始。这个函子选择了锥的底部 (base)——即图示函子 (diagram functor)。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan2.jpg}
\end{figure}

\noindent
新增的是包含单个对象（和单个恒等态射 (identity morphism)）的范畴 $\cat{1}$。从 $\cat{I}$ 到这个范畴只有一个可能的函子 $K$。它将所有对象映射到 $\cat{1}$ 中唯一的对象，并将所有态射映射到恒等态射。任何从 $\cat{1}$ 到 $\cat{C}$ 的函子 $F$ 都为我们的锥选择了一个潜在的顶点。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan15.jpg}
\end{figure}

\noindent
锥是从 $F \circ K$ 到 $D$ 的一个自然变换 (natural transformation) $\varepsilon$。注意 $F \circ K$ 的作用与我们最初的 $\Delta_c$ 完全相同。下图展示了这个变换。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan3-e1492120491591.jpg}
\end{figure}

\noindent
我们现在可以定义一个泛性质 (universal property) 来挑选“最佳”的函子 $F$。这个 $F$ 将把 $\cat{1}$ 映射到 $\cat{C}$ 中 $D$ 的极限对象，而从 $F \circ K$ 到 $D$ 的自然变换 $\varepsilon$ 将提供相应的投影 (projections)。这个泛函子 (universal functor) 被称为 $D$ 沿着 $K$ 的右 Kan 扩展 (right Kan extension)，记作 $\Ran_{K}D$。

让我们来表述这个泛性质。假设我们有另一个锥——即另一个函子 $F'$ 以及一个从 $F' \circ K$ 到 $D$ 的自然变换 $\varepsilon'$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan31-e1492120512209.jpg}
\end{figure}

\noindent
如果 Kan 扩展 $F = \Ran_{K}D$ 存在，那么必须存在一个从 $F'$ 到它的唯一自然变换 $\sigma$，使得 $\varepsilon'$ 通过 $\varepsilon$ 因子分解 (factorizes)，即：
\[\varepsilon' = \varepsilon\ .\ (\sigma \circ K)\]
这里，$\sigma \circ K$ 是两个自然变换（其中一个是 $K$ 上的恒等自然变换）的水平复合 (horizontal composition)。然后这个变换与 $\varepsilon$ 进行垂直复合 (vertically composed)。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan5.jpg}
\end{figure}

\noindent
在分量 (components) 上，当作用于 $\cat{I}$ 中的对象 $i$ 时，我们得到：
\[\varepsilon'_i = \varepsilon_i \circ \sigma_{K i}\]
在我们的例子中，$\sigma$ 只有一个对应于 $\cat{1}$ 的单个对象的分量。所以，这确实是从由 $F'$ 定义的锥的顶点到由 $\Ran_{K}D$ 定义的泛锥顶点的唯一态射 (morphism)。交换条件 (commuting conditions) 正是极限定义所要求的那些。

但重要的是，我们可以自由地将平凡范畴 $\cat{1}$ 替换为任意范畴 $\cat{A}$，右 Kan 扩展的定义仍然有效。

\section{右 Kan 扩展}

函子 $D \Colon \cat{I} \to \cat{C}$ 沿着函子 $K \Colon \cat{I} \to \cat{A}$ 的右 Kan 扩展是一个函子 $F \Colon \cat{A} \to \cat{C}$（记作 $\Ran_{K}D$）以及一个自然变换
\[\varepsilon \Colon F \circ K \to D\]
使得对于任何其他函子 $F' \Colon \cat{A} \to \cat{C}$ 和一个自然变换
\[\varepsilon' \Colon F' \circ K \to D\]
存在唯一的自然变换
\[\sigma \Colon F' \to F\]
因子分解 $\varepsilon'$：
\[\varepsilon' = \varepsilon\ .\ (\sigma \circ K)\]
这相当拗口，但可以用这个漂亮的图表来可视化：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan7.jpg}
\end{figure}

\noindent
看待这个问题的一个有趣方式是注意到，在某种意义上，Kan 扩展的作用类似于“函子乘法”的逆。一些作者甚至使用 $D/K$ 来表示 $\Ran_{K}D$。确实，在这种表示法下，同样被称为右 Kan 扩展的余单位 (counit) $\varepsilon$ 的定义看起来像简单的抵消：
\[\varepsilon \Colon D/K \circ K \to D\]
Kan 扩展还有另一种解释。考虑函子 $K$ 将范畴 $\cat{I}$ 嵌入 (embeds) 到 $\cat{A}$ 内部。在最简单的情况下，$\cat{I}$ 可能只是 $\cat{A}$ 的一个子范畴 (subcategory)。我们有一个函子 $D$ 将 $\cat{I}$ 映射到 $\cat{C}$。我们能否将 $D$ 扩展为一个定义在整个 $\cat{A}$ 上的函子 $F$？理想情况下，这样的扩展会使得复合 (composition) $F \circ K$ 与 $D$ 同构 (isomorphic)。换句话说，$F$ 将把 $D$ 的定义域扩展到 $\cat{A}$。但一个完全的同构通常要求过高，我们只需其中一半即可，即一个从 $F \circ K$ 到 $D$ 的单向自然变换 $\varepsilon$。（左 Kan 扩展选择另一个方向。）

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan6.jpg}
\end{figure}

\noindent
当然，当函子 $K$ 在对象上不是单射的 (injective) 或在 hom-集 (hom-sets) 上不是忠实的 (faithful) 时，例如在极限的例子中，嵌入的图景就不成立了。在这种情况下，Kan 扩展会尽力推断丢失的信息。

\section{Kan 扩展作为伴随}

现在假设对于任何 $D$（和固定的 $K$），右 Kan 扩展都存在。在这种情况下，$\Ran_{K}-$（短划线代替 $D$）是一个从函子范畴 (functor category) ${[}\cat{I}, \cat{C}{]}$ 到函子范畴 ${[}\cat{A}, \cat{C}{]}$ 的函子。事实证明，这个函子是前复合函子 (precomposition functor) $- \circ K$ 的右伴随 (right adjoint)。后者将 ${[}\cat{A}, \cat{C}{]}$ 中的函子映射到 ${[}\cat{I}, \cat{C}{]}$ 中的函子。伴随关系 (adjunction) 是：
\[[\cat{I}, \cat{C}](F' \circ K, D) \cong [\cat{A}, \cat{C}](F', \Ran_{K}D)\]
这只是对我们称为 $\varepsilon'$ 的每个自然变换都对应一个我们称为 $\sigma$ 的唯一自然变换这一事实的重述。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan92.jpg}
\end{figure}

\noindent
此外，如果我们选择范畴 $\cat{I}$ 与 $\cat{C}$ 相同，我们可以用恒等函子 (identity functor) $I_{\cat{C}}$ 替换 $D$。我们得到以下恒等式：
\[[\cat{C}, \cat{C}](F' \circ K, I_{\cat{C}}) \cong [\cat{A}, \cat{C}](F', \Ran_{K}I_{\cat{C}})\]
我们现在可以选择 $F'$ 与 $\Ran_{K}I_{\cat{C}}$ 相同。在这种情况下，右侧包含恒等自然变换，与之对应，左侧给出以下自然变换：
\[\varepsilon \Colon \Ran_{K}I_{\cat{C}} \circ K \to I_{\cat{C}}\]
这看起来非常像伴随的余单位：
\[\Ran_{K}I_{\cat{C}} \dashv K\]
确实，恒等函子沿着函子 $K$ 的右 Kan 扩展可用于计算 $K$ 的左伴随。为此，还需要一个条件：右 Kan 扩展必须被函子 $K$ 保持 (preserved)。扩展的保持意味着，如果我们计算与 $K$ 前复合的函子的 Kan 扩展，我们应该得到与将原始 Kan 扩展与 $K$ 前复合相同的结果。在我们的例子中，这个条件简化为：
\[K \circ \Ran_{K}I_{\cat{C}} \cong \Ran_{K}K\]
注意，使用除以 $K$ 的表示法，伴随可以写成：
\[I/K \dashv K\]
这证实了我们关于伴随描述某种逆的直觉。保持条件变为：
\[K \circ I/K \cong K/K\]
函子沿着自身的右 Kan 扩展 $K/K$ 被称为 codensity 单子 (codensity monad)。

伴随公式是一个重要的结果，因为正如我们很快将看到的，我们可以使用 end (coend) 来计算 Kan 扩展，从而为我们提供了寻找右（和左）伴随的实用方法。

\section{左 Kan 扩展}

存在一个对偶的构造，给出了左 Kan 扩展 (left Kan extension)。为了建立一些直觉，我们可以从余极限 (colimit) 的定义开始，并将其重构为使用单例范畴 $\cat{1}$。我们通过使用函子 $D \Colon \cat{I} \to \cat{C}$ 构成其底部，并使用函子 $F \Colon \cat{1} \to \cat{C}$ 选择其顶点，来构建一个余锥 (cocone)。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan81.jpg}
\end{figure}

\noindent
余锥的边，即内射 (injections)，是从 $D$ 到 $F \circ K$ 的自然变换 $\eta$ 的分量。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan10a.jpg}
\end{figure}

\noindent
余极限是泛余锥 (universal cocone)。因此对于任何其他函子 $F'$ 和一个自然变换
\[\eta' \Colon D \to F' \circ K\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan10b.jpg}
\end{figure}

\noindent
存在一个从 $F$ 到 $F'$ 的唯一自然变换 $\sigma$

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan14.jpg}
\end{figure}

\noindent
使得：
\[\eta' = (\sigma \circ K)\ .\ \eta\]
这在以下图表中说明：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan112.jpg}
\end{figure}

\noindent
将单例范畴 $\cat{1}$ 替换为 $\cat{A}$，这个定义自然地推广到左 Kan 扩展的定义，记作 $\Lan_{K}D$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan12.jpg}
\end{figure}

\noindent
自然变换：
\[\eta \Colon D \to \Lan_{K}D \circ K\]
被称为左 Kan 扩展的单位 (unit)。

像之前一样，我们可以将自然变换之间的一一对应关系：
\[\eta' = (\sigma \circ K)\ .\ \eta\]
用伴随关系来重述：
\[[\cat{A}, \cat{C}](\Lan_{K}D, F') \cong [\cat{I}, \cat{C}](D, F' \circ K)\]
换句话说，左 Kan 扩展是左伴随，右 Kan 扩展是与 $K$ 前复合的右伴随。

就像恒等函子的右 Kan 扩展可用于计算 $K$ 的左伴随一样，恒等函子的左 Kan 扩展结果是 $K$ 的右伴随（$\eta$ 是伴随的单位）：
\[K \dashv \Lan_{K}I_{\cat{C}}\]
结合这两个结果，我们得到：
\[\Ran_{K}I_{\cat{C}} \dashv K \dashv \Lan_{K}I_{\cat{C}}\]

\section{Kan 扩展作为 Ends}

Kan 扩展的真正威力在于它们可以用 end（和 coend）来计算。为简单起见，我们将注意力限制在目标范畴 $\cat{C}$ 是 $\Set$ 的情况，但这些公式可以推广到任何范畴。

让我们重温一下 Kan 扩展可用于将函子的作用扩展到其原始定义域之外的想法。假设 $K$ 将 $\cat{I}$ 嵌入到 $\cat{A}$ 内部。函子 $D$ 将 $\cat{I}$ 映射到 $\Set$。我们可以简单地说，对于 $K$ 的像 (image) 中的任何对象 $a$，即 $a = K i$，扩展后的函子将 $a$ 映射到 $D i$。问题是，对于 $\cat{A}$ 中那些在 $K$ 的像之外的对象该怎么办？想法是，每个这样的对象可能通过大量态射与 $K$ 像中的每个对象相连。函子必须保持这些态射。从对象 $a$ 到 $K$ 的像的所有态射的总体由 hom-函子 (hom-functor) 刻画：
\[\cat{A}(a, K -)\]

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/kan13.jpg}
\end{figure}

\noindent
注意，这个 hom-函子是两个函子的复合：
\[\cat{A}(a, K -) = \cat{A}(a, -) \circ K\]
右 Kan 扩展是函子复合的右伴随：
\[[\cat{I}, \Set](F' \circ K, D) \cong [\cat{A}, \Set](F', \Ran_{K}D)\]
让我们看看当用 hom 函子替换 $F'$ 时会发生什么：
\[[\cat{I}, \Set](\cat{A}(a, -) \circ K, D) \cong [\cat{A}, \Set](\cat{A}(a, -), \Ran_{K}D)\]
然后内联复合：
\[[\cat{I}, \Set](\cat{A}(a, K -), D) \cong [\cat{A}, \Set](\cat{A}(a, -), \Ran_{K}D)\]
右侧可以使用 Yoneda 引理 (Yoneda lemma) 化简：
\[[\cat{I}, \Set](\cat{A}(a, K -), D) \cong \Ran_{K}D a\]
我们现在可以将自然变换的集合重写为 end，得到这个非常方便的右 Kan 扩展公式：
\[\Ran_{K}D a \cong \int_i \Set(\cat{A}(a, K i), D i)\]
存在一个类似的用 coend 表示左 Kan 扩展的公式：
\[\Lan_{K}D a = \int^i \cat{A}(K i, a)\times{}D i\]
为了证明确实如此，我们将展示这确实是函子复合的左伴随：
\[[\cat{A}, \Set](\Lan_{K}D, F') \cong [\cat{I}, \Set](D, F' \circ K)\]
让我们将我们的公式代入左侧：
\[[\cat{A}, \Set](\int^i \cat{A}(K i, -)\times{}D i, F')\]
这是自然变换的集合，所以可以重写为一个 end：
\[\int_a \Set(\int^i \cat{A}(K i, a)\times{}D i, F' a)\]
使用 hom-函子的连续性 (continuity)，我们可以将 coend 替换为 end：
\[\int_a \int_i \Set(\cat{A}(K i, a)\times{}D i, F' a)\]
我们可以使用积-指数伴随 (product-exponential adjunction)：
\[\int_a \int_i \Set(\cat{A}(K i, a),\ (F' a)^{D i})\]
指数同构于相应的 hom-集：
\[\int_a \int_i \Set(\cat{A}(K i, a),\ \Set(D i, F' a))\]
有一个称为 Fubini 定理 (Fubini theorem) 的定理允许我们交换两个 end：
\[\int_i \int_a \Set(\cat{A}(K i, a),\ \Set(D i, F' a))\]
内部的 end 代表两个函子之间的自然变换集合，所以我们可以使用 Yoneda 引理：
\[\int_i \Set(D i, F' (K i))\]
这确实是我们着手证明的伴随关系的右侧所形成的自然变换集合：
\[[\cat{I}, \Set](D, F' \circ K)\]
这类使用 end、coend 和 Yoneda 引理的计算对于 end 的“微积分”来说是相当典型的。

\section{Haskell 中的 Kan 扩展}

Kan 扩展的 end/coend 公式可以很容易地翻译成 Haskell。让我们从右扩展开始：
\[\Ran_{K}D a \cong \int_i \Set(\cat{A}(a, K i), D i)\]
我们将 end 替换为全称量词 (universal quantifier)，将 hom-集替换为函数类型：

\src{snippet01}
看这个定义，很明显 \code{Ran} 必须包含一个类型为 \code{a} 的值，函数可以应用于该值，以及两个函子 \code{k} 和 \code{d} 之间的自然变换。例如，假设 \code{k} 是树函子，\code{d} 是列表函子，并且你得到了一个 \code{Ran Tree {[}{]} String}。如果你传递给它一个函数：

\src{snippet02}
你将得到一个 \code{Int} 列表，依此类推。右 Kan 扩展将使用你的函数来生成一棵树，然后将其重新打包成一个列表。例如，你可以传递给它一个从字符串生成解析树的解析器 (parser)，你会得到一个对应于该树的深度优先遍历 (depth-first traversal) 的列表。

右 Kan 扩展可以通过将函子 \code{d} 替换为恒等函子来计算给定函子的左伴随。这导致函子 \code{k} 的左伴随由类型为以下的多态函数集合表示：

\src{snippet03}
假设 \code{k} 是来自幺半群范畴的遗忘函子 (forgetful functor)。那么全称量词遍历所有幺半群。当然，在 Haskell 中我们无法表达幺半群定律，但以下是对产生的自由函子 (free functor) 的一个不错的近似（遗忘函子 \code{k} 在对象上是恒等的）：

\src{snippet04}
正如预期的那样，它生成自由幺半群 (free monoids)，即 Haskell 列表：

\src{snippet05}
左 Kan 扩展是一个 coend：
\[\Lan_{K}D a = \int^i \cat{A}(K i, a)\times{}D i\]
所以它翻译成一个存在量词 (existential quantifier)。符号上：

\begin{snip}{haskell}
Lan k d a = exists i. (k i -> a, d i)
\end{snip}
这可以用 Haskell 中的 \acronym{GADT}（广义代数数据类型）或使用全称量化的数据构造器来编码：

\src{snippet06}
这个数据结构的解释是，它包含一个函数，该函数接受某个未指定类型 \code{i} 的容器并产生一个 \code{a}。它还有一个那些 \code{i} 的容器。由于你不知道 \code{i} 是什么，你能对这个数据结构做的唯一事情就是检索 \code{i} 的容器，使用自然变换将其重新打包到由函子 \code{k} 定义的容器中，然后调用该函数以获得 \code{a}。例如，如果 \code{d} 是树，\code{k} 是列表，你可以序列化 (serialize) 该树，用结果列表调用该函数，并获得一个 \code{a}。

左 Kan 扩展可用于计算函子的右伴随。我们知道积函子 (product functor) 的右伴随是指数函子 (exponential)，所以让我们尝试使用 Kan 扩展来实现它：

\src{snippet07}
这确实与函数类型同构，由以下一对函数证明：

\src{snippet08}
注意，正如前面在一般情况下描述的那样，我们执行了以下步骤：

\begin{enumerate}
  \tightlist
  \item
        检索 \code{x} 的容器（这里，它只是一个平凡的恒等容器），以及函数 \code{f}。
  \item
        使用恒等函子和对函子之间的自然变换重新打包容器。
  \item
        调用函数 \code{f}。
\end{enumerate}

\section{自由函子}

Kan 扩展的一个有趣应用是自由函子 (free functor) 的构造。它解决了以下实际问题：假设你有一个类型构造器 (type constructor)——即对象的映射。是否有可能基于这个类型构造器定义一个函子？换句话说，我们能否定义一个态射的映射，将这个类型构造器扩展为一个完全成熟的自函子 (endofunctor)？

关键的观察是，类型构造器可以描述为一个其定义域是离散范畴 (discrete category) 的函子。离散范畴除了恒等态射外没有其他态射。给定一个范畴 $\cat{C}$，我们总是可以通过简单地丢弃所有非恒等态射来构造一个离散范畴 $\cat{|C|}$。从 $\cat{|C|}$ 到 $\cat{C}$ 的函子 $F$ 则是一个简单的对象映射，或者我们称之为 Haskell 中的类型构造器。还有一个规范的函子 $J$ 将 $\cat{|C|}$ 注入 (injects) $\cat{C}$ 中：它在对象上（以及恒等态射上）是恒等的。$F$ 沿着 $J$ 的左 Kan 扩展，如果存在，则是一个从 $\cat{C}$ 到 $\cat{C}$ 的函子：
\[\Lan_{J}F a = \int^i \cat{C}(J i, a)\times{}F i\]
它被称为基于 $F$ 的自由函子。

在 Haskell 中，我们会这样写：

\src{snippet09}
确实，对于任何类型构造器 \code{f}，\code{FreeF f} 都是一个函子：

\src{snippet10}
正如你所见，自由函子通过记录函数及其参数来伪造 (fakes) 函数的提升。它通过记录提升后函数的复合来累积它们。函子规则自动满足。这个构造在一篇论文 \urlref{http://okmij.org/ftp/Haskell/extensible/more.pdf}{Freer Monads, More Extensible Effects} 中被使用过。

或者，我们可以为此目的使用右 Kan 扩展：

\src{snippet11}
很容易检查这确实是一个函子：

\src{snippet12}