% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{幺}{半群 (Monoids) 是一个重要}的概念，无论在范畴论 (category theory) 还是在编程中。范畴对应于强类型语言，而幺半群对应于无类型语言。这是因为在幺半群中，你可以组合任意两个态射 (arrows)，就像在无类型语言中你可以组合任意两个函数 (functions)（当然，执行程序时可能会遇到运行时错误 (runtime error)）。

我们已经看到，幺半群可以被描述为一个只有一个对象的范畴，其中所有的逻辑都编码在态射 (morphism) 组合的规则中。这个范畴模型与更传统的集合论 (set-theoretical) 定义的幺半群完全等价，在集合论定义中，我们将集合中的两个元素进行“乘法 (multiply)”运算得到第三个元素。这个“乘法”过程可以进一步分解为：首先形成一个元素对，然后将这个元素对等同于一个已有的元素——它们的“积 (product)”。

如果我们放弃乘法的第二部分——将元素对与现有元素等同起来——会发生什么？例如，我们可以从一个任意集合开始，形成所有可能的元素对，并将它们称为新元素。然后我们将这些新元素与所有可能的元素配对，以此类推。这是一个链式反应——我们将永远不断地添加新元素。结果是一个无限集，它将 \emph{几乎} 是一个幺半群。但是幺半群还需要一个单位元 (unit element) 和结合律 (law of associativity)。没问题，我们可以添加一个特殊的单位元，并等同化一些元素对——刚好足以支持单位元和结合律。

让我们看一个简单的例子来说明这是如何工作的。我们从一个包含两个元素的集合 $\{a, b\}$ 开始。我们称它们为自由幺半群 (free monoid) 的生成元 (generators)。首先，我们添加一个特殊元素 $e$ 作为单位元。接下来，我们添加所有元素对，并称它们为“积”。$a$ 和 $b$ 的积将是元素对 $(a, b)$。$b$ 和 $a$ 的积将是元素对 $(b, a)$，$a$ 与 $a$ 的积将是 $(a, a)$，$b$ 与 $b$ 的积将是 $(b, b)$。我们也可以与 $e$ 形成元素对，例如 $(a, e)$, $(e, b)$ 等，但我们会将它们等同于 $a$, $b$ 等。所以在这一轮中，我们只添加 $(a, a)$, $(a, b)$, $(b, a)$ 和 $(b, b)$，最终得到集合 $\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}$。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{images/bunnies.jpg}
\end{figure}

\noindent
在下一轮中，我们将继续添加像这样的元素：$(a, (a, b))$, $((a, b), a)$ 等。此时，我们必须确保结合律成立，因此我们将 $(a, (b, a))$ 与 $((a, b), a)$ 等同起来，依此类推。换句话说，我们将不再需要内部的括号。

你可以猜到这个过程的最终结果是什么：我们将创建所有可能的由 $a$ 和 $b$ 组成的列表 (lists)。事实上，如果我们将 $e$ 表示为空列表，我们可以看到我们的“乘法”只不过是列表连接 (list concatenation)。

这种构造方式，即不断生成元素的所有可能组合，并执行最少次数的等同化——刚好足以维持定律——被称为自由构造 (free construction)。我们刚才所做的就是从生成元集合 $\{a, b\}$ 构造了一个 \newterm{自由幺半群}。

\section{Haskell 中的自由幺半群}

Haskell 中的二元集合等价于类型 \code{Bool}，由此集合生成的自由幺半群等价于类型 \code{{[}Bool{]}} (\code{Bool} 的列表)。(我故意忽略了无限列表的问题。)

Haskell 中的幺半群由类型类 (type class) 定义：

\src{snippet01}
这说明每个 \code{Monoid} 必须有一个称为 \code{mempty} 的单位元 (neutral element)，以及一个称为 \code{mappend} 的二元函数 (binary function)（乘法）。单位元和结合律无法在 Haskell 中表达，必须由程序员在每次实例化幺半群时进行验证。

任何类型的列表都构成一个幺半群，这一事实由这个实例定义 (instance definition) 描述：

\src{snippet02}
它声明空列表 \code{{[}{]}} 是单位元，列表连接 \code{(++)} 是二元运算 (binary operation)。

正如我们所见，类型为 \code{a} 的列表对应于一个自由幺半群，其中集合 \code{a} 作为生成元。带有乘法运算的自然数集合不是一个自由幺半群，因为我们等同化了许多积。例如，比较：

\src{snippet03}
这很简单，但问题是，我们能否在范畴论中执行这种自由构造，在范畴论中我们不允许查看对象的内部？我们将使用我们的主力方法：泛构造 (universal construction)。

第二个有趣的问题是，任何幺半群是否都可以通过等同化（比定律要求的最低数量更多的）自由幺半群中的元素来获得？我将向你展示，这直接源自泛构造。

\section{自由幺半群的泛构造}

如果你回想一下我们之前关于泛构造的经验，你可能会注意到，它与其说是构造某个东西，不如说是选择一个最符合给定模式 (pattern) 的对象。因此，如果我们想使用泛构造来“构造”一个自由幺半群，我们必须考虑一大堆幺半群，并从中挑选一个。我们需要一个完整的幺半群范畴来进行选择。但是幺半群能构成一个范畴吗？

让我们首先将幺半群视为配备了由单位元和乘法定义的附加结构 (additional structure) 的集合。我们将选择那些保持幺半群结构的函数作为态射。这种保持结构的函数称为 \newterm{同态 (homomorphisms)}。幺半群同态必须将两个元素的积映射为这两个元素映射后的积：

\src{snippet04}
并且它必须将单位元映射到单位元。

例如，考虑一个从整数列表（带有连接运算）到整数（带有乘法运算）的同态。如果我们将 \code{{[}2{]}} 映射到 2，将 \code{{[}3{]}} 映射到 3，那么我们必须将 \code{{[}2, 3{]}} 映射到 6，因为连接运算

\src{snippet05}
变成了乘法运算

\src{snippet06}
现在让我们忘记单个幺半群的内部结构，只将它们视为具有相应态射的对象。你会得到一个幺半群范畴 $\cat{Mon}$。

好的，也许在我们忘记内部结构之前，让我们注意一个重要的性质。$\cat{Mon}$ 中的每个对象都可以平凡地映射到一个集合。它就是其元素的集合。这个集合称为 \newterm{底层 (underlying)} 集合。事实上，我们不仅可以将 $\cat{Mon}$ 的对象映射到集合，还可以将 $\cat{Mon}$ 的态射（同态）映射到函数。再次强调，这看起来有点微不足道，但很快就会变得有用。这种从 $\cat{Mon}$ 到 $\Set$ 的对象和态射的映射实际上是一个函子 (functor)。由于这个函子“遗忘”了幺半群结构——一旦我们进入一个普通集合内部，我们就不再区分单位元或关心乘法——它被称为 \newterm{遗忘函子 (forgetful functor)}。遗忘函子在范畴论中经常出现。

我们现在对 $\cat{Mon}$ 有了两种不同的看法。我们可以像对待任何其他具有对象和态射的范畴一样对待它。在这种观点下，我们看不到幺半群的内部结构。关于 $\cat{Mon}$ 中的特定对象，我们所能说的只是它通过态射连接到自身和其他对象。态射的“乘法”表——组合规则——是从另一种观点推导出来的：作为集合的幺半群。通过转向范畴论，我们并没有完全失去这种观点——我们仍然可以通过我们的遗忘函子访问它。

要应用泛构造，我们需要定义一个特殊的性质，使我们能够搜索幺半群范畴并为自由幺半群挑选最佳候选者。但是自由幺半群是由其生成元定义的。不同的生成元选择会产生不同的自由幺半群（\code{Bool} 列表与 \code{Int} 列表不同）。我们的构造必须从一个生成元集合开始。所以我们又回到了集合！

这就是遗忘函子发挥作用的地方。我们可以用它来透视我们的幺半群。我们可以在这些对象的透视图中识别出生成元。它是这样工作的：

我们从一个生成元集合 $x$ 开始。这是 $\Set$ 中的一个集合。

我们要匹配的模式包含一个幺半群 $m$——$\cat{Mon}$ 的一个对象——以及 $\Set$ 中的一个函数 $p$：

\src{snippet07}
其中 $U$ 是我们从 $\cat{Mon}$ 到 $\Set$ 的遗忘函子。这是一个奇怪的异构 (heterogeneous) 模式——一半在 $\cat{Mon}$ 中，一半在 $\Set$ 中。

其思想是函数 $p$ 将在 $m$ 的透视图中识别出生成元集合。函数在识别集合内部点方面可能表现不佳（它们可能会将点合并）这并不重要。这一切都将由泛构造来解决，它将挑选出该模式的最佳代表。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-pattern.jpg}
\end{figure}

\noindent
我们还必须定义候选者之间的排序 (ranking)。假设我们有另一个候选者：一个幺半群 $n$ 和一个在其透视图中识别生成元的函数：

\src{snippet08}
如果存在一个幺半群态射（即保持结构的同态）：

\src{snippet09}
它在 $U$ 下的像（记住，$U$ 是一个函子，所以它将态射映射到函数）通过 $p$ 分解 (factorizes)：

\src{snippet10}
我们就说 $m$ 优于 $n$。如果你将 $p$ 看作在 $m$ 中选择生成元；将 $q$ 看作在 $n$ 中选择“相同”的生成元；那么你可以将 $h$ 看作在这两个幺半群之间映射这些生成元。记住，$h$ 根据定义保持了幺半群结构。这意味着一个幺半群中两个生成元的积将被映射到第二个幺半群中相应两个生成元的积，依此类推。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\textwidth]{images/monoid-ranking.jpg}
\end{figure}

\noindent
这个排序可以用来找到最佳候选者——自由幺半群。定义如下：

\begin{quote}
  我们称 $m$ （连同函数 $p$）是以 $x$ 为生成元的 \textbf{自由幺半群}，当且仅当对于任何其他幺半群 $n$（连同函数 $q$），存在一个 \emph{唯一的} 态射 $h: m \to n$ 满足上述分解性质。
\end{quote}
顺便说一下，这回答了我们的第二个问题。函数 $U h$ 具有将 $U m$ 的多个元素合并 (collapse) 为 $U n$ 单个元素的能力。这种合并对应于等同化自由幺半群中的某些元素。因此，任何以 $x$ 为生成元的幺半群都可以通过等同化基于 $x$ 的自由幺半群中的某些元素来获得。自由幺半群是只进行了最少必要等同化的幺半群。

我们将在讨论伴随 (adjunctions) 时再回到自由幺半群。

\section{挑战}

\begin{enumerate}
  \tightlist
  \item
        你可能（像我最初那样）认为，要求幺半群同态保持单位元是多余的。毕竟，我们知道对于所有的 $a$

        \begin{snip}{text}
h a * h e = h (a * e) = h a
\end{snip}
        所以 $h e$ 的作用像一个右单位元（类似地，也像一个左单位元）。问题在于，对于所有的 $a$，$h a$ 可能只覆盖了目标幺半群的一个子幺半群 (sub-monoid)。可能存在一个“真正的”单位元在 $h$ 的像 (image) 之外。证明一个保持乘法运算的幺半群同构 (isomorphism) 必须自动保持单位元。
  \item
        考虑一个从（带有连接运算的）整数列表到（带有乘法运算的）整数的幺半群同态。空列表 \code{{[}{]}} 的像是什么？假设所有单元列表 (singleton lists) 都映射到它们包含的整数，即 \code{{[}3{]}} 映射到 3，等等。\code{{[}1, 2, 3, 4{]}} 的像是什么？有多少个不同的列表映射到整数 12？这两个幺半群之间是否存在其他的同态？
  \item
        由单元集合 (one-element set) 生成的自由幺半群是什么？你能看出它同构于什么吗？
\end{enumerate}
